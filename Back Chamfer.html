<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Back Chamfer</title>
    <style>
        body {
            font-family: "Times New Roman", serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            padding: 20px;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        svg {
            border: 1px solid #ddd;
            background-color: #fff;
            margin-bottom: 20px;
        }
        .input-group {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            width: 100%;
        }
        input[type="text"] {
            padding: 10px;
            font-size: 18px;
            width: 300px;
            text-align: center;
            border: 2px solid #007bff;
            border-radius: 4px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #218838;
        }
        .hint {
            color: #666;
            font-size: 14px;
            margin-top: 5px;
        }
        .error {
            color: red;
            font-size: 14px;
            height: 20px;
        }
    </style>
</head>
<body>

<div class="container">
    <svg id="drawingSvg" width="800" height="500" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- 填充保持旋转 -45 度 -->
            <pattern id="mixedHatch" patternUnits="userSpaceOnUse" width="30" height="30" patternTransform="rotate(-45)">
                <line x1="0" y1="0" x2="30" y2="0" stroke="#000" stroke-width="1" />
                <line x1="0" y1="15" x2="30" y2="15" stroke="#000" stroke-width="1" stroke-dasharray="8,6" />
            </pattern>
            
            <!-- 圆点标记 -->
            <marker id="dot" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto">
                <circle cx="4" cy="4" r="3" fill="red" />
            </marker>
        </defs>
        <g id="svgContent"></g>
    </svg>
    
    <div class="input-group">
        <label for="specInput" style="font-weight: bold; font-size: 1.2em;">输入规格文字:</label>
        <input type="text" id="specInput" value="1W背倒20*27余3光" placeholder="例如: 1W背倒20*27余3光">
        <div class="error" id="errorMsg"></div>
        
        <button onclick="downloadJPG()">下载 JPG 图片</button>
        
        <div class="hint">支持格式示例: 1W背倒20*27余3光 / 2L背倒15*10余5</div>
    </div>
</div>

<script>
    const svg = document.getElementById('drawingSvg');
    const svgContent = document.getElementById('svgContent');
    const input = document.getElementById('specInput');
    const errorMsg = document.getElementById('errorMsg');

    parseAndDraw();
    input.addEventListener('input', parseAndDraw);

    function parseAndDraw() {
        const text = input.value.trim();
        const regex = /^(\d+)([WL])背倒(\d+)\*(\d+)余(\d+)(光?)$/i;
        const match = text.match(regex);

        if (!match) {
            errorMsg.textContent = "格式无法识别，请参照示例：1W背倒20*27余3光";
            return;
        } else {
            errorMsg.textContent = "";
        }

        const data = {
            index: match[1],
            dimType: match[2].toUpperCase(),
            cutWidth: parseInt(match[3]),
            cutHeight: parseInt(match[4]),
            remaining: parseInt(match[5]),
            isPolished: match[6] === '光'
        };
        data.totalThickness = data.cutHeight + data.remaining;
        drawSVG(data, text);
    }

    function drawSVG(data, originalText) {
        while (svgContent.firstChild) {
            svgContent.removeChild(svgContent.firstChild);
        }

        const width = parseInt(svg.getAttribute('width'));
        const height = parseInt(svg.getAttribute('height'));
        
        // --- 布局参数配置 ---
        const sidePadding = 30;    // 左右留白
        const topPadding = 40;     // 顶部留白
        const bottomAreaHeight = 60; // 底部预留给文字的高度 (比之前小，让图更大)
        
        // 计算绘图区的可用空间
        const availableW = width - sidePadding * 2;
        const availableH = height - topPadding - bottomAreaHeight; 

        const logicalH = data.totalThickness;
        const logicalW = logicalH * 5.5; // 保持长宽比
        
        // 计算缩放比例，让图形尽可能大
        const scale = Math.min(availableW / logicalW, availableH / logicalH) * 0.85;

        // 计算图形居中位置 (在绘图区内居中)
        const offsetX = sidePadding + (availableW - logicalW * scale) / 2;
        const offsetY = topPadding + (availableH - logicalH * scale) / 2;

        const toX = (val) => offsetX + val * scale;
        const toY = (val) => offsetY + val * scale;

        // 坐标点
        const pTopLeft = { x: toX(0), y: toY(0) };
        const pChamferStart = { x: toX(0), y: toY(data.remaining) };
        const pChamferEnd = { x: toX(data.cutWidth), y: toY(data.totalThickness) };
        const pBottomRight = { x: toX(logicalW), y: toY(data.totalThickness) };
        const pTopRight = { x: toX(logicalW), y: toY(0) };

        const points = `
            ${pTopLeft.x},${pTopLeft.y} 
            ${pChamferStart.x},${pChamferStart.y} 
            ${pChamferEnd.x},${pChamferEnd.y} 
            ${pBottomRight.x},${pBottomRight.y} 
            ${pTopRight.x},${pTopRight.y}
        `;
        
        // 1. 填充
        createSvgElement('polygon', {
            points: points,
            fill: 'url(#mixedHatch)',
            stroke: 'none'
        });
        
        // 2. 轮廓
        createSvgElement('polygon', {
            points: points,
            fill: 'none',
            stroke: 'black',
            'stroke-width': 3
        });

        // 3. 标注
        // 3.1 顶部 W/L
        const topY = pTopLeft.y - 30;
        drawDimLine(pTopLeft.x, topY, pTopRight.x, topY, data.dimType, false, -25, 36);
        createLine(pTopLeft.x, pTopLeft.y, pTopLeft.x, topY - 5);
        createLine(pTopRight.x, pTopRight.y, pTopRight.x, topY - 5);

        // 3.2 右侧 T
        const rightX = pTopRight.x + 45;
        drawDimLine(rightX, pTopRight.y, rightX, pBottomRight.y, data.totalThickness + "T", true, 20);
        createLine(pTopRight.x, pTopRight.y, rightX + 5, pTopRight.y);
        createLine(pBottomRight.x, pBottomRight.y, rightX + 5, pBottomRight.y);

        // 3.3 左侧标注
        const leftLabelX = pTopLeft.x - 45;
        
        // 剩余高度
        drawDimLine(leftLabelX, pTopLeft.y, leftLabelX, pChamferStart.y, data.remaining, true, -20);
        createLine(pTopLeft.x, pTopLeft.y, leftLabelX - 5, pTopLeft.y);
        createLine(pChamferStart.x, pChamferStart.y, leftLabelX - 5, pChamferStart.y);

        // 切去高度
        drawDimLine(leftLabelX, pChamferStart.y, leftLabelX, pChamferEnd.y, data.cutHeight, true, -20);
        createLine(pChamferEnd.x, pChamferEnd.y, leftLabelX - 5, pChamferEnd.y);

        // 3.4 底部切宽
        const bottomLabelY = pBottomRight.y + 40;
        const cutX = pChamferEnd.x;
        const zeroX = pTopLeft.x;
        
        drawDimLine(zeroX, bottomLabelY, cutX, bottomLabelY, data.cutWidth, false, -10);
        createLine(zeroX, pBottomRight.y, zeroX, bottomLabelY + 5);
        createLine(cutX, pBottomRight.y, cutX, bottomLabelY + 5);

        // 4. 三角标记
        const triHalfW = 6;
        const triLen = 12;
        const triGap = 8;

        // 4.1 顶部三角
        const topTriX = (pTopLeft.x + pTopRight.x) / 2;
        const topTriY = pTopLeft.y - triGap; 
        createSvgElement('polygon', {
            points: `${topTriX - triHalfW},${topTriY - triLen} ${topTriX + triHalfW},${topTriY - triLen} ${topTriX},${topTriY}`,
            fill: 'black'
        });

        // 4.2 左侧光三角
        if (data.isPolished) {
            const sideTriX = pTopLeft.x - triGap;
            const sideTriY = (pTopLeft.y + pChamferStart.y) / 2;
            createSvgElement('polygon', {
                points: `${sideTriX - triLen},${sideTriY - triHalfW} ${sideTriX},${sideTriY} ${sideTriX - triLen},${sideTriY + triHalfW}`,
                fill: 'black'
            });
        }

        // 5. 底部文字 (无框，位置上移)
        createSvgElement('text', {
            x: width / 2,
            y: height - 30, // 距离底部 30px，比之前更靠上
            'text-anchor': 'middle',
            'dominant-baseline': 'middle',
            'font-family': 'Times New Roman',
            'font-size': '40px',
            fill: 'black'
        }, originalText);
    }

    function createSvgElement(type, attrs, textContent) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (const [key, value] of Object.entries(attrs)) {
            el.setAttribute(key, value);
        }
        if (textContent) {
            el.textContent = textContent;
        }
        svgContent.appendChild(el);
        return el;
    }

    function createLine(x1, y1, x2, y2) {
        createSvgElement('line', {
            x1: x1, y1: y1, x2: x2, y2: y2,
            stroke: 'red', 'stroke-width': 1
        });
    }

    function drawDimLine(x1, y1, x2, y2, text, isVertical, textOffset = 0, fontSize = 24) {
        createSvgElement('line', {
            x1: x1, y1: y1, x2: x2, y2: y2,
            stroke: 'red', 'stroke-width': 1,
            'marker-start': 'url(#dot)',
            'marker-end': 'url(#dot)'
        });

        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        
        const textAttrs = {
            'font-family': 'Times New Roman',
            'font-size': fontSize + 'px',
            fill: 'red',
            'text-anchor': 'middle',
            'dominant-baseline': 'middle'
        };

        if (isVertical) {
            textAttrs.transform = `rotate(-90, ${midX}, ${midY})`;
            textAttrs.y = midY + textOffset; 
            textAttrs.x = midX;
        } else {
            textAttrs.x = midX;
            textAttrs.y = midY + textOffset; 
        }
        
        createSvgElement('text', textAttrs, text);
    }

    function downloadJPG() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const scaleFactor = 2;
        const w = parseInt(svg.getAttribute('width'));
        const h = parseInt(svg.getAttribute('height'));
        
        canvas.width = w * scaleFactor;
        canvas.height = h * scaleFactor;
        
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svg);
        
        if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
            source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }
        if(!source.match(/^<svg[^>]+"http\:\/\/www\.w3\.org\/1999\/xlink"/)){
            source = source.replace(/^<svg/, '<svg xmlns:xlink="http://www.w3.org/1999/xlink"');
        }

        const img = new Image();
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(source);
        
        img.onload = function() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            const a = document.createElement('a');
            a.download = input.value + '.jpg';
            a.href = canvas.toDataURL('image/jpeg', 0.9);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
    }
</script>

</body>
</html>
