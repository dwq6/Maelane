<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>板材加工图生成器</title>
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- 引入 Babel 用于解析 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; }
    </style>
</head>
<body class="bg-gray-100">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect } = React;

        // --- 图标组件 ---
        const IconBase = ({ children, className, ...props }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>
        );
        const ArrowUp = (props) => <IconBase {...props}><path d="m5 12 7-7 7 7"/><path d="M12 19V5"/></IconBase>;
        const ArrowDown = (props) => <IconBase {...props}><path d="M12 5v14"/><path d="m19 12-7 7-7-7"/></IconBase>;
        const ArrowLeft = (props) => <IconBase {...props}><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></IconBase>;
        const ArrowRight = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></IconBase>;
        const Circle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/></IconBase>;
        const Plus = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="M12 5v14"/></IconBase>;
        const Minus = (props) => <IconBase {...props}><path d="M5 12h14"/></IconBase>;
        const Copy = (props) => <IconBase {...props}><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></IconBase>;
        const Check = (props) => <IconBase {...props}><path d="M20 6 9 17l-5-5"/></IconBase>;
        const Download = (props) => <IconBase {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>;
        const Loader2 = ({ className, ...props }) => <IconBase className={`animate-spin ${className}`} {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconBase>;

        // --- 组件：方向按钮 ---
        const MiniBtn = ({ active, onClick, children, title }) => (
            <button 
            onClick={onClick}
            title={title}
            className={`w-10 h-10 rounded-lg flex items-center justify-center border transition-all active:scale-95 ${
                active 
                ? 'bg-red-600 border-red-600 text-white shadow-md' 
                : 'bg-white border-gray-200 text-gray-400 hover:border-gray-400 hover:bg-gray-50'
            }`}
            >
            {children}
            </button>
        );

        // --- 组件：厚度选择按钮 ---
        const ThicknessBtn = ({ active, onClick, label }) => (
            <button 
            onClick={onClick}
            className={`flex-1 py-2 rounded-lg text-sm font-bold border transition-all active:scale-95 ${
                active 
                ? 'bg-gray-800 border-gray-800 text-white shadow-md' 
                : 'bg-white border-gray-200 text-gray-600 hover:border-gray-300 hover:bg-gray-50'
            }`}
            >
            {label}
            </button>
        );

        // --- 组件：数字步进器 ---
        const NumberControl = ({ value, onChange, label, step = 1, min = 0, disabled = false, rightElement = null }) => {
            const handleMinus = () => {
            const newVal = Math.max(min, (parseFloat(value) || 0) - step);
            onChange(newVal.toString());
            };
            const handlePlus = () => {
            const newVal = (parseFloat(value) || 0) + step;
            onChange(newVal.toString());
            };

            return (
            <div className="flex flex-col">
                <div className="flex justify-between items-center mb-1 h-[15px]">
                    {label && <span className="text-[10px] font-bold text-gray-400 uppercase ml-1">{label}</span>}
                    {rightElement}
                </div>
                <div className={`flex items-center bg-white border border-gray-200 rounded-lg overflow-hidden h-10 w-full shadow-sm hover:border-gray-300 transition-colors ${disabled ? 'opacity-40 pointer-events-none' : ''}`}>
                <button 
                    onClick={handleMinus} 
                    disabled={disabled}
                    className="w-8 h-full flex items-center justify-center bg-gray-50 hover:bg-gray-100 border-r border-gray-100 active:bg-gray-200 text-gray-600 transition-colors"
                >
                    <Minus size={14} />
                </button>
                <input 
                    type="number" 
                    value={value} 
                    onChange={(e) => onChange(e.target.value)} 
                    disabled={disabled}
                    className="flex-1 w-full text-center text-sm font-medium focus:outline-none text-gray-700" 
                />
                <button 
                    onClick={handlePlus} 
                    disabled={disabled}
                    className="w-8 h-full flex items-center justify-center bg-gray-50 hover:bg-gray-100 border-l border-gray-100 active:bg-gray-200 text-gray-600 transition-colors"
                >
                    <Plus size={14} />
                </button>
                </div>
            </div>
            );
        };

        const Triangle = ({ x, y, direction, rotate }) => {
            let points = "";
            const size = 10; 
            const half = size / 2;
            const height = size; 

            if (direction === 'down') points = `${x},${y} ${x - half},${y - height} ${x + half},${y - height}`;
            else if (direction === 'up') points = `${x},${y} ${x - half},${y + height} ${x + half},${y + height}`;
            else if (direction === 'right') points = `${x},${y} ${x - height},${y - half} ${x - height},${y + half}`;
            else if (direction === 'left') points = `${x},${y} ${x + height},${y - half} ${x + height},${y + half}`;
            else points = `${x},${y} ${x - half},${y - height} ${x + half},${y - height}`; 

            return <polygon points={points} fill="black" transform={rotate ? `rotate(${rotate} ${x} ${y})` : undefined} />;
        };

        // 辅助组件：补角圆点
        const CornerDot = ({ x, y, color, r = 1.0 }) => (
            <circle cx={x} cy={y} r={r} fill={color} />
        );

        const GrindingGenerator = () => {
            // --- 基础配置 ---
            const COLOR_RED = "#ff0000"; 
            const COLOR_BLACK = "black";
            const COLOR_DIM = "#ff0000"; 

            // --- 状态 ---
            const [sides, setSides] = useState({
            top: false, bottom: false, left: false, right: false, center: true
            });
            const [topChamfer, setTopChamfer] = useState('3');
            const [bottomChamfer, setBottomChamfer] = useState('2');
            const [thicknesses, setThicknesses] = useState(['20']); 
            const [bottomPolish, setBottomPolish] = useState('15'); 
            const [isFullPolish, setIsFullPolish] = useState(false); 
            const [drawingNo, setDrawingNo] = useState('');
            const [showTopChamferTriangle, setShowTopChamferTriangle] = useState(false); 
            
            const [copied, setCopied] = useState(false);
            const [isDownloading, setIsDownloading] = useState(false);
            const svgRef = useRef(null); 
            const sectionRef = useRef(null); 

            const toggleSide = (side) => {
            setSides(prev => ({ ...prev, [side]: !prev[side] }));
            };

            const toggleThickness = (val) => {
            setThicknesses(prev => {
                if (prev.includes(val)) {
                return prev.filter(t => t !== val);
                } else {
                return [...prev, val].sort((a, b) => parseFloat(a) - parseFloat(b));
                }
            });
            };

            // --- 智能标注生成逻辑 ---
            const generateLabel = () => {
            let lPart = "";
            let wPart = "";
            
            const activeSideCount = [sides.top, sides.bottom, sides.left, sides.right].filter(Boolean).length;

            if (sides.top && sides.bottom) {
                lPart = "2L";
            } else if (sides.top) {
                lPart = activeSideCount === 1 ? "1L" : "上L";
            } else if (sides.bottom) {
                lPart = activeSideCount === 1 ? "1L" : "下L";
            }

            if (sides.left && sides.right) {
                wPart = "2W";
            } else if (sides.left) {
                wPart = activeSideCount === 1 ? "1W" : "左W";
            } else if (sides.right) {
                wPart = activeSideCount === 1 ? "1W" : "右W";
            }

            let parts = [];
            const isBottomLOnly = sides.bottom && !sides.top;
            
            if (lPart && wPart) {
                if (isBottomLOnly) {
                parts = [wPart, lPart];
                } else {
                parts = [lPart, wPart];
                }
            } else {
                if (lPart) parts.push(lPart);
                if (wPart) parts.push(wPart);
            }

            let sideText = parts.length > 0 ? parts.join("+") + "侧磨" : "";
            
            const tVal = parseFloat(topChamfer) || 0;
            const bVal = parseFloat(bottomChamfer) || 0;
            let chamferText = "";
            
            if (tVal > 0 && bVal > 0) {
                chamferText = `上倒${tVal}mm下倒${bVal}mm`;
            } else if (tVal > 0) {
                chamferText = `倒角${tVal}mm`;
            } else if (bVal > 0) {
                chamferText = `下倒${bVal}mm`;
            }

            let combinedTop = sideText;
            if (sideText && chamferText) combinedTop += chamferText;
            else if (chamferText) combinedTop += chamferText;

            let bottomText = "";
            if (isFullPolish) bottomText = ", 底部全光";
            else if (bottomPolish && bottomPolish !== '0') bottomText = `, 底部进${bottomPolish}mm`;

            return (combinedTop + bottomText).trim();
            };

            const fullLabel = generateLabel();
            
            const displayLabel = drawingNo ? `图${drawingNo}: ${fullLabel}` : fullLabel;

            const copyText = () => {
            navigator.clipboard.writeText(displayLabel); 
            setCopied(true);
            setTimeout(() => setCopied(false), 2000);
            };

            const downloadImage = async () => {
            if (isDownloading) return;
            setIsDownloading(true);
            
            try {
                const svg1 = svgRef.current;
                const svg2 = sectionRef.current;
                if (!svg1 || !svg2) throw new Error("SVG not found");

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // --- 4倍高清导出设置 ---
                const scale = 4; 
                const totalWidth = 800; 
                const totalHeight = 1000; 
                canvas.width = totalWidth * scale;
                canvas.height = totalHeight * scale;
                
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const loadSvg = (svg, x, y, w, h) => {
                return new Promise((resolve, reject) => {
                    try {
                    let data = new XMLSerializer().serializeToString(svg);
                    if (!data.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
                        data = data.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
                    }
                    // 关键：将 SVG 内部尺寸也放大，确保栅格化清晰
                    data = data.replace(/^<svg/, `<svg width="${w}" height="${h}"`);

                    const blob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const img = new Image();
                    img.onload = () => {
                        ctx.drawImage(img, x, y, w, h);
                        URL.revokeObjectURL(url);
                        resolve();
                    };
                    img.onerror = (e) => {
                        console.error("Image load error", e);
                        reject(e);
                    };
                    img.src = url;
                    } catch (e) {
                    reject(e);
                    }
                });
                };

                await Promise.all([
                loadSvg(svg1, 100 * scale, 50 * scale, 600 * scale, 400 * scale),      
                loadSvg(svg2, 100 * scale, 500 * scale, 600 * scale, 400 * scale)      
                ]);

                ctx.fillStyle = 'black';
                // 字体大小也乘以 scale
                ctx.font = `bold ${32 * scale}px Arial, "Microsoft YaHei", sans-serif`;
                ctx.textAlign = 'center';
                
                // 坐标乘以 scale
                ctx.fillText(displayLabel, (totalWidth / 2) * scale, (totalHeight - 40) * scale);

                let fileName = '板材加工图.png';
                if (drawingNo) {
                    fileName = `${drawingNo}_${fullLabel || '加工图'}.png`;
                } else if (fullLabel) {
                    fileName = `${fullLabel}.png`;
                }

                const pngUrl = canvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = pngUrl;
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (err) {
                console.error("Download failed:", err);
                alert("下载失败，请重试或截图保存");
            } finally {
                setIsDownloading(false);
            }
            };

            // --- 正面图渲染 ---
            const renderTopView = () => {
            const RW = 120; 
            const RH = 80;
            const MarginLeft = 55; 
            const MarginRight = 15; 
            const MarginTop = 45;   
            const MarginBottom = 25; 

            const W = MarginLeft + RW + MarginRight;
            const H = MarginTop + RH + MarginBottom;
            const rx = MarginLeft;
            const ry = MarginTop;
            const cx = rx + RW / 2;
            const cy = ry + RH / 2;
            const dimOff = 25;

            const getStrokeColor = (isSideActive) => {
                return (isSideActive && sides.center) ? COLOR_RED : COLOR_BLACK;
            };

            return (
                <svg ref={svgRef} viewBox={`0 0 ${W} ${H}`} preserveAspectRatio="xMidYMid meet" className="w-full h-full">
                <rect x="0" y="0" width={W} height={H} fill="white" />
                
                <line x1={rx} y1={ry} x2={rx + RW} y2={ry} stroke={getStrokeColor(sides.top)} strokeWidth="1" strokeLinecap="square" />
                <line x1={rx} y1={ry + RH} x2={rx + RW} y2={ry + RH} stroke={getStrokeColor(sides.bottom)} strokeWidth="1" strokeLinecap="square" />
                <line x1={rx} y1={ry} x2={rx} y2={ry + RH} stroke={getStrokeColor(sides.left)} strokeWidth="1" strokeLinecap="square" />
                <line x1={rx + RW} y1={ry} x2={rx + RW} y2={ry + RH} stroke={getStrokeColor(sides.right)} strokeWidth="1" strokeLinecap="square" />

                <line x1={rx} y1={ry - dimOff} x2={rx + RW} y2={ry - dimOff} stroke={COLOR_DIM} strokeWidth="0.5" />
                <circle cx={rx} cy={ry - dimOff} r="1.5" fill={COLOR_DIM} />
                <circle cx={rx + RW} cy={ry - dimOff} r="1.5" fill={COLOR_DIM} />
                <line x1={rx} y1={ry - 3} x2={rx} y2={ry - dimOff - 5} stroke={COLOR_DIM} strokeWidth="0.5" />
                <line x1={rx + RW} y1={ry - 3} x2={rx + RW} y2={ry - dimOff - 5} stroke={COLOR_DIM} strokeWidth="0.5" />
                <text x={cx} y={ry - dimOff - 3} textAnchor="middle" fill={COLOR_DIM} fontSize="12" fontFamily="serif">L</text>

                <line x1={rx - dimOff} y1={ry} x2={rx - dimOff} y2={ry + RH} stroke={COLOR_DIM} strokeWidth="0.5" />
                <circle cx={rx - dimOff} cy={ry} r="1.5" fill={COLOR_DIM} />
                <circle cx={rx - dimOff} cy={ry + RH} r="1.5" fill={COLOR_DIM} />
                <line x1={rx - 3} y1={ry} x2={rx - dimOff - 5} y2={ry} stroke={COLOR_DIM} strokeWidth="0.5" />
                <line x1={rx - 3} y1={ry + RH} x2={rx - dimOff - 5} y2={ry + RH} stroke={COLOR_DIM} strokeWidth="0.5" />
                <text x={rx - dimOff - 3} y={cy} textAnchor="end" dominantBaseline="middle" fill={COLOR_DIM} fontSize="12" fontFamily="serif">W</text>

                {sides.top && <Triangle x={cx} y={ry - 3} direction="down" />}
                {sides.bottom && <Triangle x={cx} y={ry + RH + 3} direction="up" />}
                {sides.left && <Triangle x={rx - 3} y={cy} direction="right" />}
                {sides.right && <Triangle x={rx + RW + 3} y={cy} direction="left" />}
                
                <Triangle x={cx} y={cy + 5} direction="down" />
                </svg>
            );
            };

            // --- 截面图渲染 ---
            const renderSectionView = () => {
            const DRAW_HEIGHT = 60; 
            const DRAW_WIDTH = 130; 
            
            const sx = 60; 
            const sy = 40; 
            
            const VIEW_W = sx + DRAW_WIDTH + 15; 
            const VIEW_H = 160; 

            const baseThickness = parseFloat(thicknesses[0]) || 30;
            const thicknessLabel = thicknesses.length > 0 ? thicknesses.join(',') + "T" : "";

            const realTopC = parseFloat(topChamfer) || 0;
            const realBottomC = parseFloat(bottomChamfer) || 0;
            const realBottomPolish = parseFloat(bottomPolish) || 0;

            const scale = DRAW_HEIGHT / (baseThickness > 0 ? baseThickness : 1);

            const T = DRAW_HEIGHT; 
            const C_Top = realTopC * scale;
            const C_Bottom = realBottomC * scale;
            const B_Polish_W = isFullPolish ? DRAW_WIDTH : Math.min(realBottomPolish * scale, DRAW_WIDTH);

            const p1 = { x: sx + C_Top, y: sy }; 
            const p2 = { x: sx + DRAW_WIDTH, y: sy }; 
            const p3 = { x: sx + DRAW_WIDTH, y: sy + T }; 
            const p4 = { x: sx + C_Bottom, y: sy + T }; 
            const p5 = { x: sx, y: sy + C_Top }; 
            const p6 = { x: sx, y: sy + T - C_Bottom }; 

            const redLineEndX = sx + Math.max(C_Bottom, B_Polish_W);
            const bottomDimCenterX = sx + (redLineEndX - sx) / 2;
            const bottomTriangleX = bottomDimCenterX;

            const chamferOffset = 22;

            const endX = p2.x;
            const midY = sy + T / 2;
            const zH = 12; 
            const zW = 6;  
            const extension = 8; 

            const zigzagCore = `
                L ${endX} ${midY - zH/2}
                L ${endX - zW} ${midY - zH/4}
                L ${endX + zW} ${midY + zH/4}
                L ${endX} ${midY + zH/2}
            `;

            const rightFillPath = `
                L ${endX} ${sy}
                ${zigzagCore}
                L ${endX} ${sy + T}
            `;

            const breakLinePath = `
                M ${endX} ${sy - extension}
                L ${endX} ${sy}
                ${zigzagCore}
                L ${endX} ${sy + T}
                L ${endX} ${sy + T + extension}
            `;

            const fillPath = `
                M ${p1.x} ${p1.y} 
                ${rightFillPath}
                L ${p4.x} ${p4.y} 
                L ${p6.x} ${p6.y} 
                L ${p5.x} ${p5.y} 
                Z
            `;

            const isSidePolished = true; 
            const R_RED = 1.0;

            // 计算上倒角三角位置
            const chamferMidX = sx + C_Top / 2;
            const chamferMidY = sy + C_Top / 2;
            // 三角偏移量 2px
            const triangleOffset = 2;

            return (
                <svg ref={sectionRef} viewBox={`0 0 ${VIEW_W} ${VIEW_H}`} preserveAspectRatio="xMidYMid meet" className="w-full h-full">
                <defs>
                    <pattern id="hatch_thin_fix_v45" width="10" height="10" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
                    <line x1="0" y1="0" x2="0" y2="10" style={{stroke:'black', strokeWidth:0.5}} />
                    </pattern>
                </defs>

                {/* 1. 填充层 */}
                <path d={fillPath} fill="url(#hatch_thin_fix_v45)" stroke="none" />
                
                {/* 2. 轮廓绘制层 */}
                <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={sides.center ? COLOR_RED : COLOR_BLACK} strokeWidth={sides.center ? "1" : "0.8"} strokeLinecap="butt" />
                <path d={breakLinePath} stroke={COLOR_BLACK} strokeWidth="0.8" fill="none" strokeLinejoin="round" strokeLinecap="butt" />
                
                <line x1={p4.x} y1={p4.y} x2={redLineEndX} y2={p4.y} stroke={COLOR_RED} strokeWidth="1" strokeLinecap="butt" />
                {redLineEndX < p3.x && <line x1={redLineEndX} y1={p4.y} x2={p3.x} y2={p3.y} stroke={COLOR_BLACK} strokeWidth="0.8" strokeLinecap="butt" />}
                
                <line x1={p5.x} y1={p5.y} x2={p6.x} y2={p6.y} stroke={isSidePolished ? COLOR_RED : COLOR_BLACK} strokeWidth={isSidePolished ? "1" : "0.8"} strokeLinecap="butt" />
                {C_Top > 0 && <line x1={p5.x} y1={p5.y} x2={p1.x} y2={p1.y} stroke={COLOR_RED} strokeWidth="1" strokeLinecap="butt" />}
                {C_Bottom > 0 && <line x1={p6.x} y1={p6.y} x2={p4.x} y2={p4.y} stroke={COLOR_RED} strokeWidth="1" strokeLinecap="butt" />}
                
                {/* 3. 补角层 */}
                <CornerDot x={p5.x} y={p5.y} color={COLOR_RED} r={R_RED} />
                <CornerDot x={p6.x} y={p6.y} color={COLOR_RED} r={R_RED} />
                {C_Top > 0 && <CornerDot x={p1.x} y={p1.y} color={COLOR_RED} r={R_RED} />}
                {C_Bottom > 0 && <CornerDot x={p4.x} y={p4.y} color={COLOR_RED} r={R_RED} />}
                {C_Top === 0 && <CornerDot x={p5.x} y={p5.y} color={COLOR_RED} r={R_RED} />}
                {C_Bottom === 0 && <CornerDot x={p6.x} y={p6.y} color={COLOR_RED} r={R_RED} />}

                {/* 4. 标注层 */}
                <Triangle x={sx + DRAW_WIDTH/2} y={sy - 4} direction="down" />
                
                <Triangle x={sx - 4} y={sy + T/2} direction="right" />
                
                {(sides.bottom || realBottomPolish > 0 || isFullPolish) && (
                    <Triangle x={bottomTriangleX} y={sy + T + 4} direction="up" />
                )}

                {/* 上倒角磨光三角 (垂直于倒角边，带偏移) */}
                {showTopChamferTriangle && C_Top > 0 && (
                    <Triangle x={chamferMidX - triangleOffset} y={chamferMidY - triangleOffset} direction="down" rotate={-45} />
                )}

                {/* 厚度标注 (只有当选择了厚度时才显示) */}
                {thicknesses.length > 0 && (
                    <g>
                    <line x1={sx - 35} y1={sy} x2={sx - 35} y2={sy + T} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={sx - 40} y1={sy} x2={sx - 15} y2={sy} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={sx - 40} y1={sy + T} x2={sx - 15} y2={sy + T} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <circle cx={sx - 35} cy={sy} r="1.5" fill={COLOR_DIM} />
                    <circle cx={sx - 35} cy={sy + T} r="1.5" fill={COLOR_DIM} />
                    <text 
                        x={sx - 45} 
                        y={sy + T/2} 
                        fill={COLOR_DIM} 
                        textAnchor="middle" 
                        dominantBaseline="middle" 
                        fontSize="16" 
                        fontFamily="serif" 
                        transform={`rotate(-90 ${sx-45} ${sy + T/2})`}
                    >
                        {thicknessLabel}
                    </text>
                    </g>
                )}

                {/* 上倒角标注 */}
                {C_Top > 0 && (
                    <g>
                    <line x1={p5.x} y1={p5.y} x2={p5.x - chamferOffset} y2={p5.y - chamferOffset} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p1.x} y1={p1.y} x2={p1.x - chamferOffset} y2={p1.y - chamferOffset} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p5.x - (chamferOffset-4)} y1={p5.y - (chamferOffset-4)} x2={p1.x - (chamferOffset-4)} y2={p1.y - (chamferOffset-4)} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p5.x - (chamferOffset-4) - 2} y1={p5.y - (chamferOffset-4) + 2} x2={p5.x - (chamferOffset-4) + 2} y2={p5.y - (chamferOffset-4) - 2} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p1.x - (chamferOffset-4) - 2} y1={p1.y - (chamferOffset-4) + 2} x2={p1.x - (chamferOffset-4) + 2} y2={p1.y - (chamferOffset-4) - 2} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <text x={(p5.x + p1.x)/2 - chamferOffset} y={(p5.y + p1.y)/2 - chamferOffset} dy="-3" fill={COLOR_DIM} textAnchor="middle" fontSize="14" transform={`rotate(-45 ${(p5.x + p1.x)/2 - chamferOffset} ${(p5.y + p1.y)/2 - chamferOffset})`}>{realTopC}</text>
                    </g>
                )}

                {/* 下倒角标注 */}
                {C_Bottom > 0 && (
                    <g>
                    <line x1={p6.x} y1={p6.y} x2={p6.x - chamferOffset} y2={p6.y + chamferOffset} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p4.x} y1={p4.y} x2={p4.x - chamferOffset} y2={p4.y + chamferOffset} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p6.x - (chamferOffset-4)} y1={p6.y + (chamferOffset-4)} x2={p4.x - (chamferOffset-4)} y2={p4.y + (chamferOffset-4)} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p6.x - (chamferOffset-4) - 2} y1={p6.y + (chamferOffset-4) - 2} x2={p6.x - (chamferOffset-4) + 2} y2={p6.y + (chamferOffset-4) + 2} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={p4.x - (chamferOffset-4) - 2} y1={p4.y + (chamferOffset-4) - 2} x2={p4.x - (chamferOffset-4) + 2} y2={p4.y + (chamferOffset-4) + 2} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <text x={(p6.x + p4.x)/2 - chamferOffset} y={(p6.y + p4.y)/2 + chamferOffset} dy="14" fill={COLOR_DIM} textAnchor="middle" fontSize="14" transform={`rotate(45 ${(p6.x + p4.x)/2 - chamferOffset} ${(p6.y + p4.y)/2 + chamferOffset})`}>{realBottomC}</text>
                    </g>
                )}

                {/* 底部进位标注 */}
                {!isFullPolish && realBottomPolish > 0 && (
                    <g>
                    <line x1={sx} y1={sy + T + 15} x2={sx} y2={sy + T + 55} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={redLineEndX} y1={sy + T + 15} x2={redLineEndX} y2={sy + T + 55} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <line x1={sx} y1={sy + T + 45} x2={redLineEndX} y2={sy + T + 45} stroke={COLOR_DIM} strokeWidth="0.5" />
                    <circle cx={sx} cy={sy + T + 45} r="1.5" fill={COLOR_DIM} />
                    <circle cx={redLineEndX} cy={sy + T + 45} r="1.5" fill={COLOR_DIM} />
                    <text x={bottomDimCenterX} y={sy + T + 40} fill={COLOR_DIM} textAnchor="middle" fontSize="14">{realBottomPolish}</text>
                    </g>
                )}
                </svg>
            );
            };

            return (
            <div className="bg-gray-100 min-h-screen font-sans text-gray-800 p-4 md:p-8">
                <div className="max-w-6xl mx-auto flex flex-col md:flex-row gap-6 items-start pb-32 md:pb-0">
                
                {/* --- 左侧：控制面板 --- */}
                <div className="w-full md:w-80 shrink-0 flex flex-col gap-4">
                    <div className="bg-white p-5 rounded-2xl shadow-sm border border-gray-200">
                    
                    {/* 磨边位置 */}
                    <div className="mb-6">
                        <span className="text-xs font-bold text-gray-400 uppercase mb-3 block tracking-wider">磨边位置</span>
                        <div className="flex justify-between gap-2">
                        <MiniBtn active={sides.top} onClick={() => toggleSide('top')} title="上"><ArrowUp size={18} /></MiniBtn>
                        <MiniBtn active={sides.bottom} onClick={() => toggleSide('bottom')} title="下"><ArrowDown size={18} /></MiniBtn>
                        <MiniBtn active={sides.left} onClick={() => toggleSide('left')} title="左"><ArrowLeft size={18} /></MiniBtn>
                        <MiniBtn active={sides.right} onClick={() => toggleSide('right')} title="右"><ArrowRight size={18} /></MiniBtn>
                        </div>
                    </div>

                    {/* 数值控制 */}
                    <div className="grid grid-cols-1 gap-4">
                        <div className="grid grid-cols-2 gap-3">
                        <NumberControl 
                            label="上倒角" 
                            value={topChamfer} 
                            onChange={setTopChamfer} 
                            step={0.5} 
                            rightElement={
                                <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200 transition-colors" title="显示倒角磨光三角">
                                    <input type="checkbox" checked={showTopChamferTriangle} onChange={(e) => setShowTopChamferTriangle(e.target.checked)} className="w-3 h-3" />
                                    磨光
                                </label>
                            }
                        />
                        <NumberControl label="下倒角" value={bottomChamfer} onChange={setBottomChamfer} step={0.5} />
                        </div>
                        
                        {/* 厚度选择 (多选) */}
                        <div className="flex flex-col">
                        <span className="text-[10px] font-bold text-gray-400 uppercase mb-1 ml-1">板材厚度 (可多选)</span>
                        <div className="flex gap-2">
                            <ThicknessBtn label="20" active={thicknesses.includes('20')} onClick={() => toggleThickness('20')} />
                            <ThicknessBtn label="30" active={thicknesses.includes('30')} onClick={() => toggleThickness('30')} />
                            <ThicknessBtn label="50" active={thicknesses.includes('50')} onClick={() => toggleThickness('50')} />
                        </div>
                        </div>
                        
                        {/* 底部进 & 图号 (并排) */}
                        <div className="grid grid-cols-2 gap-3 mt-2">
                            {/* 左侧：底部进 (修复对齐) */}
                            <NumberControl 
                                label="底部进" 
                                value={bottomPolish} 
                                onChange={setBottomPolish} 
                                step={1} 
                                disabled={isFullPolish}
                                rightElement={
                                    <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200 transition-colors">
                                        <input type="checkbox" checked={isFullPolish} onChange={(e) => setIsFullPolish(e.target.checked)} className="w-3 h-3" />
                                        全光
                                    </label>
                                }
                            />

                            {/* 右侧：图号 */}
                            <div className="flex flex-col">
                                <div className="flex justify-between items-center mb-1 h-[15px]">
                                    <span className="text-[10px] font-bold text-gray-400 uppercase ml-1">图号</span>
                                </div>
                                <div className="flex items-center bg-white border border-gray-200 rounded-lg overflow-hidden h-10 w-full shadow-sm hover:border-gray-300 transition-colors">
                                    <input 
                                        type="text" 
                                        value={drawingNo} 
                                        onChange={(e) => setDrawingNo(e.target.value)} 
                                        placeholder="输入图号"
                                        className="flex-1 w-full text-center text-sm font-medium focus:outline-none text-gray-700 px-2" 
                                    />
                                </div>
                            </div>
                        </div>

                    </div>
                    </div>

                    {/* 电脑端：操作按钮 */}
                    <div className="hidden md:flex flex-col gap-3">
                    <div className="bg-white p-3 rounded-xl border border-gray-200 text-gray-700 font-mono text-sm flex items-center justify-between shadow-sm">
                        <span className="truncate font-bold mr-2">{displayLabel || "未选择加工"}</span>
                        <button onClick={copyText} className="p-2 hover:bg-gray-100 rounded-lg text-gray-500 transition-colors" title="复制文本">
                        {copied ? <Check size={16} className="text-green-500" /> : <Copy size={16} />}
                        </button>
                    </div>
                    <button 
                        onClick={downloadImage} 
                        disabled={isDownloading}
                        className="w-full py-3 bg-black text-white rounded-xl text-sm font-bold hover:bg-gray-800 active:scale-95 transition-all flex items-center justify-center gap-2 shadow-lg disabled:opacity-70 disabled:cursor-not-allowed"
                    >
                        {isDownloading ? <Loader2 size={18} className="animate-spin" /> : <Download size={18} />}
                        {isDownloading ? "生成中..." : "下载图片"}
                    </button>
                    </div>
                </div>

                {/* --- 右侧：绘图展示区 --- */}
                <div className="flex-1 w-full grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6">
                    
                    {/* 正面图 */}
                    <div className="w-full aspect-[4/3] bg-white p-4 rounded-2xl shadow-sm border border-gray-200 flex items-center justify-center overflow-hidden relative group">
                    <div className="absolute top-2 left-3 text-xs font-bold text-gray-300 uppercase">正面图</div>
                    {renderTopView()}
                    </div>

                    {/* 截面图 */}
                    <div className="w-full aspect-[4/3] bg-white p-4 rounded-2xl shadow-sm border border-gray-200 flex items-center justify-center overflow-hidden relative group">
                    <div className="absolute top-2 left-3 text-xs font-bold text-gray-300 uppercase">截面图</div>
                    {renderSectionView()}
                    </div>

                </div>

                {/* --- 手机端：底部悬浮操作栏 --- */}
                <div className="md:hidden fixed bottom-4 left-4 right-4 z-50">
                    <div className="bg-white/95 backdrop-blur-md p-2 rounded-2xl shadow-xl border border-gray-200/50 flex gap-2 items-center">
                    <div className="flex-1 bg-gray-50 px-3 py-3 rounded-xl border border-gray-100 text-gray-700 font-mono flex items-center justify-between text-sm">
                        <span className="truncate font-bold">{displayLabel || "未选择"}</span>
                        <button onClick={copyText} className="ml-2 p-1.5 bg-white border rounded-lg text-gray-500 active:bg-gray-100">
                        {copied ? <Check size={14} className="text-green-500" /> : <Copy size={14} />}
                        </button>
                    </div>
                    <button 
                        onClick={downloadImage} 
                        disabled={isDownloading}
                        className="px-5 py-3 bg-black text-white rounded-xl text-sm font-bold active:scale-95 transition-transform flex items-center gap-2 shadow-md whitespace-nowrap disabled:opacity-70"
                    >
                        {isDownloading ? <Loader2 size={18} className="animate-spin" /> : <Download size={18} />}
                        {isDownloading ? "..." : "下载"}
                    </button>
                    </div>
                </div>

                </div>
            </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<GrindingGenerator />);
    </script>
</body>
</html>
