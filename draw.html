import React, { useState, useRef } from 'react';
import { Download, ArrowUp, ArrowDown, ArrowLeft, ArrowRight, Circle, Plus, Minus, Copy, Check, Loader2 } from 'lucide-react';

// --- 组件：方向按钮 ---
const MiniBtn = ({ active, onClick, children, title }) => (
  <button 
    onClick={onClick}
    title={title}
    className={`w-10 h-10 rounded-lg flex items-center justify-center border transition-all active:scale-95 ${
      active 
        ? 'bg-red-600 border-red-600 text-white shadow-md' 
        : 'bg-white border-gray-200 text-gray-400 hover:border-gray-400 hover:bg-gray-50'
    }`}
  >
    {children}
  </button>
);

// --- 组件：厚度选择按钮 ---
const ThicknessBtn = ({ active, onClick, label }) => (
  <button 
    onClick={onClick}
    className={`flex-1 py-2 rounded-lg text-sm font-bold border transition-all active:scale-95 ${
      active 
        ? 'bg-gray-800 border-gray-800 text-white shadow-md' 
        : 'bg-white border-gray-200 text-gray-600 hover:border-gray-300 hover:bg-gray-50'
    }`}
  >
    {label}
  </button>
);

// --- 组件：数字步进器 ---
const NumberControl = ({ value, onChange, label, step = 1, min = 0, disabled = false }) => {
  const handleMinus = () => {
    const newVal = Math.max(min, (parseFloat(value) || 0) - step);
    onChange(newVal.toString());
  };
  const handlePlus = () => {
    const newVal = (parseFloat(value) || 0) + step;
    onChange(newVal.toString());
  };

  return (
    <div className={`flex flex-col ${disabled ? 'opacity-40 pointer-events-none' : ''}`}>
      <span className="text-[10px] font-bold text-gray-400 uppercase mb-1 ml-1">{label}</span>
      <div className="flex items-center bg-white border border-gray-200 rounded-lg overflow-hidden h-10 w-full shadow-sm hover:border-gray-300 transition-colors">
        <button 
          onClick={handleMinus} 
          disabled={disabled}
          className="w-8 h-full flex items-center justify-center bg-gray-50 hover:bg-gray-100 border-r border-gray-100 active:bg-gray-200 text-gray-600 transition-colors"
        >
          <Minus size={14} />
        </button>
        <input 
          type="number" 
          value={value} 
          onChange={(e) => onChange(e.target.value)} 
          disabled={disabled}
          className="flex-1 w-full text-center text-sm font-medium focus:outline-none text-gray-700" 
        />
        <button 
          onClick={handlePlus} 
          disabled={disabled}
          className="w-8 h-full flex items-center justify-center bg-gray-50 hover:bg-gray-100 border-l border-gray-100 active:bg-gray-200 text-gray-600 transition-colors"
        >
          <Plus size={14} />
        </button>
      </div>
    </div>
  );
};

const Triangle = ({ x, y, direction }) => {
  let points = "";
  const size = 10; 
  const half = size / 2;
  const height = size; 

  if (direction === 'down') points = `${x},${y} ${x - half},${y - height} ${x + half},${y - height}`;
  else if (direction === 'up') points = `${x},${y} ${x - half},${y + height} ${x + half},${y + height}`;
  else if (direction === 'right') points = `${x},${y} ${x - height},${y - half} ${x - height},${y + half}`;

  return <polygon points={points} fill="black" />;
};

// 辅助组件：补角圆点
const CornerDot = ({ x, y, color, r = 1.5 }) => (
  <circle cx={x} cy={y} r={r} fill={color} />
);

const GrindingGenerator = () => {
  // --- 基础配置 ---
  const COLOR_RED = "#ff0000"; 
  const COLOR_BLACK = "black";
  const COLOR_DIM = "#ff0000"; 

  // --- 状态 ---
  const [sides, setSides] = useState({
    top: false, bottom: false, left: false, right: false, center: true
  });
  const [topChamfer, setTopChamfer] = useState('3');
  const [bottomChamfer, setBottomChamfer] = useState('2');
  const [thicknesses, setThicknesses] = useState(['30']);
  const [bottomPolish, setBottomPolish] = useState('15'); 
  const [isFullPolish, setIsFullPolish] = useState(false); 
  
  const [copied, setCopied] = useState(false);
  const [isDownloading, setIsDownloading] = useState(false);
  const svgRef = useRef(null); 
  const sectionRef = useRef(null); 

  const toggleSide = (side) => {
    setSides(prev => ({ ...prev, [side]: !prev[side] }));
  };

  const toggleThickness = (val) => {
    setThicknesses(prev => {
      if (prev.includes(val)) {
        if (prev.length === 1) return prev;
        return prev.filter(t => t !== val);
      } else {
        return [...prev, val].sort((a, b) => parseFloat(a) - parseFloat(b));
      }
    });
  };

  // --- 智能标注生成逻辑 ---
  const generateLabel = () => {
    let lPart = "";
    let wPart = "";
    
    const activeSideCount = [sides.top, sides.bottom, sides.left, sides.right].filter(Boolean).length;

    // 1. 生成 L 部分文字
    if (sides.top && sides.bottom) {
      lPart = "2L";
    } else if (sides.top) {
      lPart = activeSideCount === 1 ? "1L" : "上L";
    } else if (sides.bottom) {
      lPart = activeSideCount === 1 ? "1L" : "下L";
    }

    // 2. 生成 W 部分文字
    if (sides.left && sides.right) {
      wPart = "2W";
    } else if (sides.left) {
      wPart = activeSideCount === 1 ? "1W" : "左W";
    } else if (sides.right) {
      wPart = activeSideCount === 1 ? "1W" : "右W";
    }

    // 3. 组合逻辑 (排序)
    let parts = [];
    const isBottomLOnly = sides.bottom && !sides.top;
    
    if (lPart && wPart) {
      if (isBottomLOnly) {
        parts = [wPart, lPart];
      } else {
        parts = [lPart, wPart];
      }
    } else {
      if (lPart) parts.push(lPart);
      if (wPart) parts.push(wPart);
    }

    let sideText = parts.length > 0 ? parts.join("+") + "侧磨" : "";
    
    const tVal = parseFloat(topChamfer) || 0;
    const bVal = parseFloat(bottomChamfer) || 0;
    let chamferText = "";
    
    if (tVal > 0 && bVal > 0) {
      chamferText = `上倒${tVal}下倒${bVal}`;
    } else if (tVal > 0) {
      chamferText = `倒角${tVal}mm`;
    } else if (bVal > 0) {
      chamferText = `下倒${bVal}`;
    }

    let combinedTop = sideText;
    if (sideText && chamferText) combinedTop += chamferText;
    else if (chamferText) combinedTop += chamferText;

    let bottomText = "";
    if (isFullPolish) bottomText = ", 底部全光";
    else if (bottomPolish && bottomPolish !== '0') bottomText = `, 底部进${bottomPolish}mm`;

    return (combinedTop + bottomText).trim();
  };

  const fullLabel = generateLabel();

  const copyText = () => {
    navigator.clipboard.writeText(fullLabel);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const downloadImage = async () => {
    if (isDownloading) return;
    setIsDownloading(true);
    
    try {
      const svg1 = svgRef.current;
      const svg2 = sectionRef.current;
      if (!svg1 || !svg2) throw new Error("SVG not found");

      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      const totalWidth = 800; 
      const totalHeight = 1000; 
      canvas.width = totalWidth;
      canvas.height = totalHeight;
      
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, totalWidth, totalHeight);

      const loadSvg = (svg, x, y, w, h) => {
        return new Promise((resolve, reject) => {
          try {
            let data = new XMLSerializer().serializeToString(svg);
            if (!data.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)) {
                data = data.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
            }
            data = data.replace(/^<svg/, `<svg width="${w}" height="${h}"`);

            const blob = new Blob([data], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const img = new Image();
            img.onload = () => {
              ctx.drawImage(img, x, y, w, h);
              URL.revokeObjectURL(url);
              resolve();
            };
            img.onerror = (e) => {
              console.error("Image load error", e);
              reject(e);
            };
            img.src = url;
          } catch (e) {
            reject(e);
          }
        });
      };

      await Promise.all([
        loadSvg(svg1, 100, 50, 600, 400),      
        loadSvg(svg2, 100, 500, 600, 400)      
      ]);

      ctx.fillStyle = 'black';
      ctx.font = 'bold 32px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(fullLabel, totalWidth / 2, totalHeight - 50);

      const fileName = fullLabel ? `${fullLabel}.png` : '板材加工图.png';
      const pngUrl = canvas.toDataURL('image/png');
      const link = document.createElement('a');
      link.href = pngUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    } catch (err) {
      console.error("Download failed:", err);
      alert("下载失败，请重试或截图保存");
    } finally {
      setIsDownloading(false);
    }
  };

  // --- 正面图渲染 ---
  const renderTopView = () => {
    const RW = 120; 
    const RH = 80;
    const MarginLeft = 55; 
    const MarginRight = 15; 
    const MarginTop = 45;   
    const MarginBottom = 25; 

    const W = MarginLeft + RW + MarginRight;
    const H = MarginTop + RH + MarginBottom;
    const rx = MarginLeft;
    const ry = MarginTop;
    const cx = rx + RW / 2;
    const cy = ry + RH / 2;
    const dimOff = 25;

    const getStrokeColor = (isSideActive) => {
      return (isSideActive && sides.center) ? COLOR_RED : COLOR_BLACK;
    };

    return (
      <svg ref={svgRef} viewBox={`0 0 ${W} ${H}`} preserveAspectRatio="xMidYMid meet" className="w-full h-full">
        <rect x="0" y="0" width={W} height={H} fill="white" />
        
        <line x1={rx} y1={ry} x2={rx + RW} y2={ry} stroke={getStrokeColor(sides.top)} strokeWidth="2" strokeLinecap="square" />
        <line x1={rx} y1={ry + RH} x2={rx + RW} y2={ry + RH} stroke={getStrokeColor(sides.bottom)} strokeWidth="2" strokeLinecap="square" />
        <line x1={rx} y1={ry} x2={rx} y2={ry + RH} stroke={getStrokeColor(sides.left)} strokeWidth="2" strokeLinecap="square" />
        <line x1={rx + RW} y1={ry} x2={rx + RW} y2={ry + RH} stroke={getStrokeColor(sides.right)} strokeWidth="2" strokeLinecap="square" />

        <line x1={rx} y1={ry - dimOff} x2={rx + RW} y2={ry - dimOff} stroke={COLOR_DIM} strokeWidth="1" />
        <circle cx={rx} cy={ry - dimOff} r="1.5" fill={COLOR_DIM} />
        <circle cx={rx + RW} cy={ry - dimOff} r="1.5" fill={COLOR_DIM} />
        <line x1={rx} y1={ry - 3} x2={rx} y2={ry - dimOff - 5} stroke={COLOR_DIM} strokeWidth="0.5" />
        <line x1={rx + RW} y1={ry - 3} x2={rx + RW} y2={ry - dimOff - 5} stroke={COLOR_DIM} strokeWidth="0.5" />
        <text x={cx} y={ry - dimOff - 3} textAnchor="middle" fill={COLOR_DIM} fontSize="12" fontFamily="serif">L</text>

        <line x1={rx - dimOff} y1={ry} x2={rx - dimOff} y2={ry + RH} stroke={COLOR_DIM} strokeWidth="1" />
        <circle cx={rx - dimOff} cy={ry} r="1.5" fill={COLOR_DIM} />
        <circle cx={rx - dimOff} cy={ry + RH} r="1.5" fill={COLOR_DIM} />
        <line x1={rx - 3} y1={ry} x2={rx - dimOff - 5} y2={ry} stroke={COLOR_DIM} strokeWidth="0.5" />
        <line x1={rx - 3} y1={ry + RH} x2={rx - dimOff - 5} y2={ry + RH} stroke={COLOR_DIM} strokeWidth="0.5" />
        <text x={rx - dimOff - 3} y={cy} textAnchor="end" dominantBaseline="middle" fill={COLOR_DIM} fontSize="12" fontFamily="serif">W</text>

        {sides.top && <Triangle x={cx} y={ry - 3} direction="down" />}
        {sides.bottom && <Triangle x={cx} y={ry + RH + 3} direction="up" />}
        {sides.left && <Triangle x={rx - 3} y={cy} direction="right" />}
        {sides.right && <polygon points={`${rx + RW + 3},${cy} ${rx + RW + 3 + 8},${cy - 4} ${rx + RW + 3 + 8},${cy + 4}`} fill="black" />}
        
        {sides.center && <Triangle x={cx} y={cy + 5} direction="down" />}
      </svg>
    );
  };

  // --- 截面图渲染 ---
  const renderSectionView = () => {
    const DRAW_HEIGHT = 60; 
    const DRAW_WIDTH = 130; 
    
    const sx = 60; 
    const sy = 40; 
    
    const VIEW_W = sx + DRAW_WIDTH + 15; 
    const VIEW_H = 160; 

    const baseThickness = parseFloat(thicknesses[0]) || 30;
    
    // 修改：厚度标注合并逻辑
    const thicknessLabel = thicknesses.length > 0 ? thicknesses.join(', ') + "T" : "";

    const realTopC = parseFloat(topChamfer) || 0;
    const realBottomC = parseFloat(bottomChamfer) || 0;
    const realBottomPolish = parseFloat(bottomPolish) || 0;

    const scale = DRAW_HEIGHT / (baseThickness > 0 ? baseThickness : 1);

    const T = DRAW_HEIGHT; 
    const C_Top = realTopC * scale;
    const C_Bottom = realBottomC * scale;
    const B_Polish_W = isFullPolish ? DRAW_WIDTH : Math.min(realBottomPolish * scale, DRAW_WIDTH);

    // 关键点坐标
    const p1 = { x: sx + C_Top, y: sy }; 
    const p2 = { x: sx + DRAW_WIDTH, y: sy }; 
    const p3 = { x: sx + DRAW_WIDTH, y: sy + T }; 
    const p4 = { x: sx + C_Bottom, y: sy + T }; 
    const p5 = { x: sx, y: sy + C_Top }; 
    const p6 = { x: sx, y: sy + T - C_Bottom }; 

    const redLineEndX = sx + Math.max(C_Bottom, B_Polish_W);
    const bottomDimCenterX = sx + (redLineEndX - sx) / 2;
    const bottomTriangleX = bottomDimCenterX;

    const chamferOffset = 22;

    const endX = p2.x;
    const midY = sy + T / 2;
    const zH = 12; 
    const zW = 6;  
    const extension = 8; 

    const zigzagCore = `
      L ${endX} ${midY - zH/2}
      L ${endX - zW} ${midY - zH/4}
      L ${endX + zW} ${midY + zH/4}
      L ${endX} ${midY + zH/2}
    `;

    const rightFillPath = `
      L ${endX} ${sy}
      ${zigzagCore}
      L ${endX} ${sy + T}
    `;

    const breakLinePath = `
      M ${endX} ${sy - extension}
      L ${endX} ${sy}
      ${zigzagCore}
      L ${endX} ${sy + T}
      L ${endX} ${sy + T + extension}
    `;

    const fillPath = `
      M ${p1.x} ${p1.y} 
      ${rightFillPath}
      L ${p4.x} ${p4.y} 
      L ${p6.x} ${p6.y} 
      L ${p5.x} ${p5.y} 
      Z
    `;

    const isSidePolished = true; 
    const R_RED = 1.5;

    return (
      <svg ref={sectionRef} viewBox={`0 0 ${VIEW_W} ${VIEW_H}`} preserveAspectRatio="xMidYMid meet" className="w-full h-full">
        <defs>
          <pattern id="hatch_thin_fix_v29" width="10" height="10" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
            <line x1="0" y1="0" x2="0" y2="10" style={{stroke:'black', strokeWidth:0.5}} />
          </pattern>
        </defs>

        {/* 1. 填充层 */}
        <path d={fillPath} fill="url(#hatch_thin_fix_v29)" stroke="none" />
        
        {/* 2. 轮廓绘制层 */}
        <line x1={p1.x} y1={p1.y} x2={p2.x} y2={p2.y} stroke={sides.center ? COLOR_RED : COLOR_BLACK} strokeWidth={sides.center ? "3" : "2"} strokeLinecap="butt" />
        <path d={breakLinePath} stroke={COLOR_BLACK} strokeWidth="1" fill="none" strokeLinejoin="round" strokeLinecap="butt" />
        
        <line x1={p4.x} y1={p4.y} x2={redLineEndX} y2={p4.y} stroke={COLOR_RED} strokeWidth="3" strokeLinecap="butt" />
        {redLineEndX < p3.x && <line x1={redLineEndX} y1={p4.y} x2={p3.x} y2={p3.y} stroke={COLOR_BLACK} strokeWidth="2" strokeLinecap="butt" />}
        
        <line x1={p5.x} y1={p5.y} x2={p6.x} y2={p6.y} stroke={isSidePolished ? COLOR_RED : COLOR_BLACK} strokeWidth={isSidePolished ? "3" : "2"} strokeLinecap="butt" />
        {C_Top > 0 && <line x1={p5.x} y1={p5.y} x2={p1.x} y2={p1.y} stroke={COLOR_RED} strokeWidth="3" strokeLinecap="butt" />}
        {C_Bottom > 0 && <line x1={p6.x} y1={p6.y} x2={p4.x} y2={p4.y} stroke={COLOR_RED} strokeWidth="3" strokeLinecap="butt" />}
        
        {/* 3. 补角层 */}
        <CornerDot x={p5.x} y={p5.y} color={COLOR_RED} r={R_RED} />
        <CornerDot x={p6.x} y={p6.y} color={COLOR_RED} r={R_RED} />
        {C_Top > 0 && <CornerDot x={p1.x} y={p1.y} color={COLOR_RED} r={R_RED} />}
        {C_Bottom > 0 && <CornerDot x={p4.x} y={p4.y} color={COLOR_RED} r={R_RED} />}
        {C_Top === 0 && <CornerDot x={p5.x} y={p5.y} color={COLOR_RED} r={R_RED} />}
        {C_Bottom === 0 && <CornerDot x={p6.x} y={p6.y} color={COLOR_RED} r={R_RED} />}

        {/* 4. 标注层 */}
        {sides.center && <Triangle x={sx + DRAW_WIDTH/2} y={sy - 4} direction="down" />}
        
        <Triangle x={sx - 4} y={sy + T/2} direction="right" />
        
        {(sides.bottom || realBottomPolish > 0 || isFullPolish) && (
          <Triangle x={bottomTriangleX} y={sy + T + 4} direction="up" />
        )}

        {/* 厚度标注 */}
        <g>
          <line x1={sx - 35} y1={sy} x2={sx - 35} y2={sy + T} stroke={COLOR_DIM} strokeWidth="1" />
          <line x1={sx - 40} y1={sy} x2={sx - 15} y2={sy} stroke={COLOR_DIM} strokeWidth="1" />
          <line x1={sx - 40} y1={sy + T} x2={sx - 15} y2={sy + T} stroke={COLOR_DIM} strokeWidth="1" />
          <circle cx={sx - 35} cy={sy} r="1.5" fill={COLOR_DIM} />
          <circle cx={sx - 35} cy={sy + T} r="1.5" fill={COLOR_DIM} />
          <text 
            x={sx - 45} 
            y={sy + T/2} 
            fill={COLOR_DIM} 
            textAnchor="middle" 
            dominantBaseline="middle" 
            fontSize="16" 
            fontFamily="serif" 
            transform={`rotate(-90 ${sx-45} ${sy + T/2})`}
          >
            {thicknessLabel}
          </text>
        </g>

        {/* 上倒角标注 */}
        {C_Top > 0 && (
          <g>
            <line x1={p5.x} y1={p5.y} x2={p5.x - chamferOffset} y2={p5.y - chamferOffset} stroke={COLOR_DIM} strokeWidth="0.8" />
            <line x1={p1.x} y1={p1.y} x2={p1.x - chamferOffset} y2={p1.y - chamferOffset} stroke={COLOR_DIM} strokeWidth="0.8" />
            <line x1={p5.x - (chamferOffset-4)} y1={p5.y - (chamferOffset-4)} x2={p1.x - (chamferOffset-4)} y2={p1.y - (chamferOffset-4)} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={p5.x - (chamferOffset-4) - 2} y1={p5.y - (chamferOffset-4) + 2} x2={p5.x - (chamferOffset-4) + 2} y2={p5.y - (chamferOffset-4) - 2} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={p1.x - (chamferOffset-4) - 2} y1={p1.y - (chamferOffset-4) + 2} x2={p1.x - (chamferOffset-4) + 2} y2={p1.y - (chamferOffset-4) - 2} stroke={COLOR_DIM} strokeWidth="1" />
            <text x={(p5.x + p1.x)/2 - chamferOffset} y={(p5.y + p1.y)/2 - chamferOffset} dy="-3" fill={COLOR_DIM} textAnchor="middle" fontSize="14" transform={`rotate(-45 ${(p5.x + p1.x)/2 - chamferOffset} ${(p5.y + p1.y)/2 - chamferOffset})`}>{realTopC}</text>
          </g>
        )}

        {/* 下倒角标注 */}
        {C_Bottom > 0 && (
          <g>
            <line x1={p6.x} y1={p6.y} x2={p6.x - chamferOffset} y2={p6.y + chamferOffset} stroke={COLOR_DIM} strokeWidth="0.8" />
            <line x1={p4.x} y1={p4.y} x2={p4.x - chamferOffset} y2={p4.y + chamferOffset} stroke={COLOR_DIM} strokeWidth="0.8" />
            <line x1={p6.x - (chamferOffset-4)} y1={p6.y + (chamferOffset-4)} x2={p4.x - (chamferOffset-4)} y2={p4.y + (chamferOffset-4)} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={p6.x - (chamferOffset-4) - 2} y1={p6.y + (chamferOffset-4) - 2} x2={p6.x - (chamferOffset-4) + 2} y2={p6.y + (chamferOffset-4) + 2} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={p4.x - (chamferOffset-4) - 2} y1={p4.y + (chamferOffset-4) - 2} x2={p4.x - (chamferOffset-4) + 2} y2={p4.y + (chamferOffset-4) + 2} stroke={COLOR_DIM} strokeWidth="1" />
            <text x={(p6.x + p4.x)/2 - chamferOffset} y={(p6.y + p4.y)/2 + chamferOffset} dy="14" fill={COLOR_DIM} textAnchor="middle" fontSize="14" transform={`rotate(45 ${(p6.x + p4.x)/2 - chamferOffset} ${(p6.y + p4.y)/2 + chamferOffset})`}>{realBottomC}</text>
          </g>
        )}

        {/* 底部进位标注 */}
        {!isFullPolish && realBottomPolish > 0 && (
          <g>
            <line x1={sx} y1={sy + T + 15} x2={sx} y2={sy + T + 55} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={redLineEndX} y1={sy + T + 15} x2={redLineEndX} y2={sy + T + 55} stroke={COLOR_DIM} strokeWidth="1" />
            <line x1={sx} y1={sy + T + 45} x2={redLineEndX} y2={sy + T + 45} stroke={COLOR_DIM} strokeWidth="1" />
            <circle cx={sx} cy={sy + T + 45} r="1.5" fill={COLOR_DIM} />
            <circle cx={redLineEndX} cy={sy + T + 45} r="1.5" fill={COLOR_DIM} />
            <text x={bottomDimCenterX} y={sy + T + 40} fill={COLOR_DIM} textAnchor="middle" fontSize="14">{realBottomPolish}</text>
          </g>
        )}
      </svg>
    );
  };

  return (
    <div className="bg-gray-100 min-h-screen font-sans text-gray-800 p-4 md:p-8">
      <div className="max-w-6xl mx-auto flex flex-col md:flex-row gap-6 items-start pb-32 md:pb-0">
        
        {/* --- 左侧：控制面板 --- */}
        <div className="w-full md:w-80 shrink-0 flex flex-col gap-4">
          <div className="bg-white p-5 rounded-2xl shadow-sm border border-gray-200">
            
            {/* 磨边位置 */}
            <div className="mb-6">
              <span className="text-xs font-bold text-gray-400 uppercase mb-3 block tracking-wider">磨边位置</span>
              <div className="flex justify-between gap-2">
                <MiniBtn active={sides.top} onClick={() => toggleSide('top')} title="上"><ArrowUp size={18} /></MiniBtn>
                <MiniBtn active={sides.bottom} onClick={() => toggleSide('bottom')} title="下"><ArrowDown size={18} /></MiniBtn>
                <MiniBtn active={sides.left} onClick={() => toggleSide('left')} title="左"><ArrowLeft size={18} /></MiniBtn>
                <MiniBtn active={sides.right} onClick={() => toggleSide('right')} title="右"><ArrowRight size={18} /></MiniBtn>
                <MiniBtn active={sides.center} onClick={() => toggleSide('center')} title="中心"><Circle size={12} className="fill-current" /></MiniBtn>
              </div>
            </div>

            {/* 数值控制 */}
            <div className="grid grid-cols-1 gap-4">
              <div className="grid grid-cols-2 gap-3">
                <NumberControl label="上倒角" value={topChamfer} onChange={setTopChamfer} step={0.5} />
                <NumberControl label="下倒角" value={bottomChamfer} onChange={setBottomChamfer} step={0.5} />
              </div>
              
              {/* 厚度选择 (多选) */}
              <div className="flex flex-col">
                <span className="text-[10px] font-bold text-gray-400 uppercase mb-1 ml-1">板材厚度 (可多选)</span>
                <div className="flex gap-2">
                  <ThicknessBtn label="20" active={thicknesses.includes('20')} onClick={() => toggleThickness('20')} />
                  <ThicknessBtn label="30" active={thicknesses.includes('30')} onClick={() => toggleThickness('30')} />
                  <ThicknessBtn label="50" active={thicknesses.includes('50')} onClick={() => toggleThickness('50')} />
                </div>
              </div>
              
              <div className="flex flex-col mt-2">
                <div className="flex justify-between items-center mb-1">
                   <span className="text-[10px] font-bold text-gray-400 uppercase ml-1">底部进</span>
                   <label className="flex items-center gap-1 text-[10px] cursor-pointer bg-gray-100 px-2 py-0.5 rounded hover:bg-gray-200 transition-colors">
                      <input type="checkbox" checked={isFullPolish} onChange={(e) => setIsFullPolish(e.target.checked)} className="w-3 h-3" />
                      全光
                   </label>
                </div>
                <NumberControl label="" value={bottomPolish} onChange={setBottomPolish} step={1} disabled={isFullPolish} />
              </div>
            </div>
          </div>

          {/* 电脑端：操作按钮 */}
          <div className="hidden md:flex flex-col gap-3">
            <div className="bg-white p-3 rounded-xl border border-gray-200 text-gray-700 font-mono text-sm flex items-center justify-between shadow-sm">
              <span className="truncate font-bold mr-2">{fullLabel || "未选择加工"}</span>
              <button onClick={copyText} className="p-2 hover:bg-gray-100 rounded-lg text-gray-500 transition-colors" title="复制文本">
                {copied ? <Check size={16} className="text-green-500" /> : <Copy size={16} />}
              </button>
            </div>
            <button 
              onClick={downloadImage} 
              disabled={isDownloading}
              className="w-full py-3 bg-black text-white rounded-xl text-sm font-bold hover:bg-gray-800 active:scale-95 transition-all flex items-center justify-center gap-2 shadow-lg disabled:opacity-70 disabled:cursor-not-allowed"
            >
              {isDownloading ? <Loader2 size={18} className="animate-spin" /> : <Download size={18} />}
              {isDownloading ? "生成中..." : "下载图片"}
            </button>
          </div>
        </div>

        {/* --- 右侧：绘图展示区 --- */}
        <div className="flex-1 w-full grid grid-cols-1 lg:grid-cols-2 gap-4 md:gap-6">
          
          {/* 正面图 */}
          <div className="w-full aspect-[4/3] bg-white p-4 rounded-2xl shadow-sm border border-gray-200 flex items-center justify-center overflow-hidden relative group">
            <div className="absolute top-2 left-3 text-xs font-bold text-gray-300 uppercase">正面图</div>
            {renderTopView()}
          </div>

          {/* 截面图 */}
          <div className="w-full aspect-[4/3] bg-white p-4 rounded-2xl shadow-sm border border-gray-200 flex items-center justify-center overflow-hidden relative group">
            <div className="absolute top-2 left-3 text-xs font-bold text-gray-300 uppercase">截面图</div>
            {renderSectionView()}
          </div>

        </div>

        {/* --- 手机端：底部悬浮操作栏 --- */}
        <div className="md:hidden fixed bottom-4 left-4 right-4 z-50">
          <div className="bg-white/95 backdrop-blur-md p-2 rounded-2xl shadow-xl border border-gray-200/50 flex gap-2 items-center">
            <div className="flex-1 bg-gray-50 px-3 py-3 rounded-xl border border-gray-100 text-gray-700 font-mono flex items-center justify-between text-sm">
              <span className="truncate font-bold">{fullLabel || "未选择"}</span>
              <button onClick={copyText} className="ml-2 p-1.5 bg-white border rounded-lg text-gray-500 active:bg-gray-100">
                {copied ? <Check size={14} className="text-green-500" /> : <Copy size={14} />}
              </button>
            </div>
            <button 
              onClick={downloadImage} 
              disabled={isDownloading}
              className="px-5 py-3 bg-black text-white rounded-xl text-sm font-bold active:scale-95 transition-transform flex items-center gap-2 shadow-md whitespace-nowrap disabled:opacity-70"
            >
              {isDownloading ? <Loader2 size={18} className="animate-spin" /> : <Download size={18} />}
              {isDownloading ? "..." : "下载"}
            </button>
          </div>
        </div>

      </div>
    </div>
  );
};

export default GrindingGenerator;
