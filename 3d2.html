<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæ¿æé…ç½®å™¨ V2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React -->
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
    
    <!-- Three.js (r128) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
      body { margin: 0; overflow: hidden; background: #f3f4f6; }
      .no-scrollbar::-webkit-scrollbar { display: none; }
      input[type=number]::-webkit-inner-spin-button, 
      input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; margin: 0; 
      }
      /* è‡ªå®šä¹‰æ»‘å—æ ·å¼ */
      input[type=range] {
        -webkit-appearance: none; width: 100%; background: transparent;
      }
      input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px;
      }
      input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 4px; cursor: pointer; background: #e5e7eb; border-radius: 2px;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useMemo } = React;

      // --- å›¾æ ‡ ---
      const IconUpload = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>);
      const IconTrash = () => (<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>);
      const IconSettings = () => (<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>);

      // --- 3D è¾…åŠ© ---
      const createTextSprite = (message) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const scale = 4;
        canvas.width = 256 * scale;
        canvas.height = 128 * scale;
        ctx.fillStyle = "rgba(0,0,0,0)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${40 * scale}px Arial, sans-serif`;
        ctx.fillStyle = "#dc2626"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false }));
        sprite.scale.set(4, 2, 1); 
        sprite.renderOrder = 999;
        return sprite;
      };

      const createDimensionLine = (start, end, offsetVec, labelText) => {
          const group = new THREE.Group();
          const p1 = start.clone().add(offsetVec);
          const p2 = end.clone().add(offsetVec);
          const lineMat = new THREE.LineBasicMaterial({ color: 0xdc2626 });
          const refMat = new THREE.LineBasicMaterial({ color: 0xdc2626, opacity: 0.3, transparent: true });

          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), lineMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([start, p1]), refMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([end, p2]), refMat));

          const tickSize = 0.3;
          const dir = new THREE.Vector3().subVectors(p2, p1).normalize();
          let tickDir = new THREE.Vector3(0, 1, 0); 
          if (Math.abs(dir.y) > 0.9) tickDir = new THREE.Vector3(1, 0, 0);
          
          const t1_a = p1.clone().add(tickDir.clone().multiplyScalar(tickSize/2));
          const t1_b = p1.clone().sub(tickDir.clone().multiplyScalar(tickSize/2));
          const t2_a = p2.clone().add(tickDir.clone().multiplyScalar(tickSize/2));
          const t2_b = p2.clone().sub(tickDir.clone().multiplyScalar(tickSize/2));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t1_a, t1_b]), lineMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t2_a, t2_b]), lineMat));

          const sprite = createTextSprite(labelText);
          const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          midPoint.add(offsetVec.clone().normalize().multiplyScalar(0.6));
          sprite.position.copy(midPoint);
          group.add(sprite);
          return group;
      };

      // --- 3D åœºæ™¯ç»„ä»¶ ---
      const ThreeScene = ({ dims, labels, textureUrl, textureSettings }) => {
        const mountRef = useRef(null);
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const meshRef = useRef(null);
        const dimsGroupRef = useRef(null);
        
        const [loadedTexture, setLoadedTexture] = useState(null);
        const [isReady, setIsReady] = useState(false);

        // 1. åˆå§‹åŒ–åœºæ™¯
        useEffect(() => {
          if (!mountRef.current) return;
          const width = mountRef.current.clientWidth;
          const height = mountRef.current.clientHeight;
          if (width === 0) return;

          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0xe5e7eb);
          sceneRef.current = scene;

          const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
          camera.position.set(20, 15, 20);
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(width, height);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.outputEncoding = THREE.sRGBEncoding;
          mountRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          // Lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(10, 20, 10);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          scene.add(dirLight);
          const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
          fillLight.position.set(-10, 5, -10);
          scene.add(fillLight);

          // Grid
          const gridHelper = new THREE.GridHelper(50, 50, 0x9ca3af, 0xd1d5db);
          gridHelper.position.y = -0.01;
          scene.add(gridHelper);

          // Controls
          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;

          // Mesh
          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
          const cube = new THREE.Mesh(geometry, material);
          cube.castShadow = true;
          cube.receiveShadow = true;
          scene.add(cube);
          meshRef.current = cube;

          const edges = new THREE.LineSegments(
              new THREE.EdgesGeometry(geometry), 
              new THREE.LineBasicMaterial({ color: 0x1f2937 })
          );
          cube.add(edges);

          const dimsGroup = new THREE.Group();
          scene.add(dimsGroup);
          dimsGroupRef.current = dimsGroup;

          setIsReady(true);

          let frameId;
          const animate = () => {
            frameId = requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          };
          animate();

          const resizeObserver = new ResizeObserver(() => {
              if (!mountRef.current || !renderer || !camera) return;
              const newW = mountRef.current.clientWidth;
              const newH = mountRef.current.clientHeight;
              if (newW > 0) {
                  camera.aspect = newW / newH;
                  camera.updateProjectionMatrix();
                  renderer.setSize(newW, newH);
              }
          });
          resizeObserver.observe(mountRef.current);

          return () => {
            cancelAnimationFrame(frameId);
            resizeObserver.disconnect();
            if (mountRef.current && renderer.domElement) {
              mountRef.current.removeChild(renderer.domElement);
            }
            renderer.dispose();
          };
        }, []);

        // 2. çº¹ç†åŠ è½½
        useEffect(() => {
          if (!textureUrl) {
              setLoadedTexture(null);
              return;
          }
          const loader = new THREE.TextureLoader();
          loader.load(textureUrl, (tex) => {
              tex.encoding = THREE.sRGBEncoding;
              // å¼€å¯å„å‘å¼‚æ€§è¿‡æ»¤ï¼Œé˜²æ­¢ä¾§é¢æ¨¡ç³Š
              if (rendererRef.current) {
                  tex.anisotropy = rendererRef.current.capabilities.getMaxAnisotropy();
              }
              setLoadedTexture(tex);
          });
        }, [textureUrl]);

        // 3. æ›´æ–°é€»è¾‘
        useEffect(() => {
          if (!meshRef.current || !dimsGroupRef.current) return;
          
          const mesh = meshRef.current;
          const scale = 100;
          const sx = dims.length / scale;
          const sy = dims.height / scale;
          const sz = dims.width / scale;

          // A. æ›´æ–°å‡ ä½•ä½“
          mesh.scale.set(sx, sy, sz);
          mesh.position.y = sy / 2;

          // B. æ›´æ–°æè´¨
          if (loadedTexture) {
              const { mode, scale: texScale } = textureSettings;
              
              // è®¡ç®—é‡å¤æ¬¡æ•°
              let repL = 1, repW = 1, repH = 1;
              let wrapMode = THREE.ClampToEdgeWrapping; // é»˜è®¤æ‹‰ä¼¸ (Stretch)

              if (mode !== 'stretch') {
                  // å¹³é“ºæ¨¡å¼
                  wrapMode = mode === 'mirror' ? THREE.MirroredRepeatWrapping : THREE.RepeatWrapping;
                  repL = dims.length / texScale;
                  repW = dims.width / texScale;
                  repH = dims.height / texScale;
              }

              // è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆæè´¨
              const getMat = (u, v) => {
                  const t = loadedTexture.clone(); 
                  t.wrapS = wrapMode;
                  t.wrapT = wrapMode;
                  t.repeat.set(u, v);
                  t.needsUpdate = true;
                  return new THREE.MeshStandardMaterial({ map: t, roughness: 0.8 });
              };

              // åº”ç”¨å…­ä¸ªé¢
              // Right/Left (Z, Y) - width, height
              const matSide = getMat(repW, repH);
              // Top/Bottom (X, Z) - length, width
              const matTop = getMat(repL, repW);
              // Front/Back (X, Y) - length, height
              const matFront = getMat(repL, repH);

              mesh.material = [
                  matSide, matSide, 
                  matTop, matTop,   
                  matFront, matFront 
              ];
              // å¼ºåˆ¶æ›´æ–°
              mesh.material.forEach(m => m.needsUpdate = true);
              
          } else {
              // æ¢å¤ç™½è†œ
              if (Array.isArray(mesh.material)) {
                  mesh.material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
                  mesh.material.needsUpdate = true;
              }
          }

          // C. æ›´æ–°æ ‡æ³¨
          const group = dimsGroupRef.current;
          group.clear();
          const halfX = sx / 2;
          const halfZ = sz / 2;
          const offsetDist = 1.5;
          const groundY = 0.02;

          group.add(createDimensionLine(new THREE.Vector3(-halfX, groundY, halfZ), new THREE.Vector3(halfX, groundY, halfZ), new THREE.Vector3(0, 0, offsetDist), labels.length));
          group.add(createDimensionLine(new THREE.Vector3(halfX, groundY, -halfZ), new THREE.Vector3(halfX, groundY, halfZ), new THREE.Vector3(offsetDist, 0, 0), labels.width));
          group.add(createDimensionLine(new THREE.Vector3(-halfX, 0, -halfZ), new THREE.Vector3(-halfX, sy, -halfZ), new THREE.Vector3(-offsetDist, 0, 0), labels.height));

        }, [dims, labels, loadedTexture, textureSettings]);

        return (
          <div ref={mountRef} className="w-full h-full relative bg-gray-200">
              {!isReady && <div className="absolute inset-0 flex items-center justify-center text-gray-500 font-bold">æ­£åœ¨åˆå§‹åŒ–...</div>}
          </div>
        );
      };

      const App = () => {
        const [dims, setDims] = useState({ length: 1000, width: 300, height: 150 });
        const [labels, setLabels] = useState({ length: 'L', width: 'W', height: 'T' });
        const [textureUrl, setTextureUrl] = useState(null);
        
        // æ–°å¢ï¼šçº¹ç†è®¾ç½®çŠ¶æ€
        const [textureSettings, setTextureSettings] = useState({
            mode: 'stretch', // stretch, repeat, mirror
            scale: 500       // å¹³é“ºæ—¶çš„åŸºå‡†å°ºå¯¸
        });

        const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
                if (textureUrl) URL.revokeObjectURL(textureUrl);
                setTextureUrl(URL.createObjectURL(file));
            }
        };

        return (
          <div className="flex flex-col md:flex-row h-screen w-full bg-white font-sans text-gray-800">
            <div className="relative order-1 md:order-2 flex-1 h-[50vh] md:h-full">
              <ThreeScene dims={dims} labels={labels} textureUrl={textureUrl} textureSettings={textureSettings} />
              <div className="absolute top-4 left-4 bg-white/90 backdrop-blur px-3 py-2 rounded shadow-sm border border-gray-200 text-xs text-gray-500 pointer-events-none">
                <p className="flex items-center gap-2"><span className="w-2 h-2 rounded-full bg-red-600"></span> çº¢è‰²æ–‡å­—ä¸º 3D æ ‡æ³¨</p>
                <p className="mt-1">ğŸ–±ï¸ å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</p>
              </div>
            </div>

            <div className="order-2 md:order-1 w-full md:w-96 bg-white border-r border-gray-200 flex flex-col shadow-xl z-10">
              <div className="p-5 border-b border-gray-100">
                <h1 className="text-lg font-bold text-gray-800 flex items-center gap-2"><span>ğŸ§Š</span> 3Dæ¿æé…ç½®</h1>
              </div>
              <div className="flex-1 overflow-y-auto p-5">
                <div className="mb-8">
                  <h3 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-4">å°ºå¯¸ & æ ‡æ³¨</h3>
                  
                  {/* Length */}
                  <div className="mb-4 p-3 bg-gray-50 rounded border border-gray-100">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-700 text-xs font-bold px-1.5 py-0.5 rounded">X</span>
                           <span className="text-xs font-semibold text-gray-600">é•¿åº¦ (Length)</span>
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.length} onChange={(e) => setDims({...dims, length: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ ‡æ³¨æ–‡å­—</label>
                              <input type="text" value={labels.length} onChange={(e) => setLabels({...labels, length: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-gray-900 font-mono focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>

                  {/* Width */}
                  <div className="mb-4 p-3 bg-gray-50 rounded border border-gray-100">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-700 text-xs font-bold px-1.5 py-0.5 rounded">Z</span>
                           <span className="text-xs font-semibold text-gray-600">å®½åº¦ (Width)</span>
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.width} onChange={(e) => setDims({...dims, width: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ ‡æ³¨æ–‡å­—</label>
                              <input type="text" value={labels.width} onChange={(e) => setLabels({...labels, width: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-gray-900 font-mono focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>

                  {/* Height */}
                  <div className="mb-4 p-3 bg-gray-50 rounded border border-gray-100">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-700 text-xs font-bold px-1.5 py-0.5 rounded">Y</span>
                           <span className="text-xs font-semibold text-gray-600">é«˜åº¦ (Height)</span>
                      </div>
                      <div className="grid grid-cols-2 gap-2">
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.height} onChange={(e) => setDims({...dims, height: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div>
                              <label className="block text-[10px] text-gray-400 mb-1">æ ‡æ³¨æ–‡å­—</label>
                              <input type="text" value={labels.height} onChange={(e) => setLabels({...labels, height: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-gray-900 font-mono focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>
                </div>

                <div className="pt-6 border-t border-gray-100">
                   <h3 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-4">è¡¨é¢æè´¨</h3>
                   {!textureUrl ? (
                       <label className="flex flex-col items-center justify-center w-full h-32 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-gray-100 transition-colors">
                          <div className="flex flex-col items-center justify-center pt-5 pb-6">
                              <IconUpload />
                              <p className="mb-2 text-sm text-gray-500 mt-2"><span className="font-semibold">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span></p>
                              <p className="text-xs text-gray-400">æ”¯æŒ JPG, PNG (è‡ªåŠ¨å¹³é“ºä¿®å¤)</p>
                          </div>
                          <input type="file" className="hidden" accept="image/*" onChange={handleImageUpload} />
                      </label>
                   ) : (
                       <div className="space-y-4">
                           <div className="relative w-full h-32 rounded-lg overflow-hidden border border-gray-200 group">
                               <img src={textureUrl} alt="Texture Preview" className="w-full h-full object-cover" />
                               <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                  <button onClick={() => setTextureUrl(null)} className="flex items-center gap-2 bg-white text-red-600 px-3 py-1.5 rounded-full text-xs font-bold shadow hover:bg-red-50">
                                      <IconTrash /> ç§»é™¤çº¹ç†
                                  </button>
                               </div>
                           </div>
                           
                           {/* çº¹ç†è®¾ç½®é¢æ¿ */}
                           <div className="bg-gray-50 p-3 rounded border border-gray-200">
                              <div className="flex items-center gap-2 mb-3 text-gray-700">
                                  <IconSettings />
                                  <span className="text-xs font-bold">çº¹ç†è®¾ç½®</span>
                              </div>
                              
                              <div className="space-y-3">
                                  <div>
                                      <label className="block text-[10px] text-gray-500 mb-1">é“ºè´´æ¨¡å¼</label>
                                      <select 
                                          value={textureSettings.mode}
                                          onChange={(e) => setTextureSettings({...textureSettings, mode: e.target.value})}
                                          className="w-full text-xs border border-gray-300 rounded px-2 py-1.5 bg-white outline-none focus:border-blue-500"
                                      >
                                          <option value="stretch">â†”ï¸ æ‹‰ä¼¸é“ºæ»¡ (æ— æ¥ç¼ï¼Œæ¨è)</option>
                                          <option value="mirror">ğŸª é•œåƒå¹³é“º (æ¶ˆé™¤ç¡¬è¾¹)</option>
                                          <option value="repeat">ğŸ” æ™®é€šå¹³é“º (åŸå›¾é‡å¤)</option>
                                      </select>
                                  </div>

                                  {textureSettings.mode !== 'stretch' && (
                                      <div>
                                          <div className="flex justify-between mb-1">
                                              <label className="block text-[10px] text-gray-500">çº¹ç†å•å…ƒå°ºå¯¸</label>
                                              <span className="text-[10px] text-gray-400">{textureSettings.scale}mm</span>
                                          </div>
                                          <input 
                                              type="range" 
                                              min="100" max="2000" step="50"
                                              value={textureSettings.scale}
                                              onChange={(e) => setTextureSettings({...textureSettings, scale: Number(e.target.value)})}
                                              className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                          />
                                          <p className="text-[10px] text-gray-400 mt-1">æ‹–åŠ¨æ»‘å—è°ƒæ•´çº¹ç†å¤§å°ï¼Œæ•°å€¼è¶Šå¤§é‡å¤è¶Šå°‘ã€‚</p>
                                      </div>
                                  )}
                              </div>
                           </div>
                       </div>
                   )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>
