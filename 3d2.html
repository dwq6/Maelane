<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæ¿æé…ç½®å™¨ V6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React -->
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.development.js"></script>
    <script crossorigin src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.development.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
    
    <!-- Three.js (r128) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
      body { margin: 0; overflow: hidden; background: #f3f4f6; }
      .no-scrollbar::-webkit-scrollbar { display: none; }
      input[type=number]::-webkit-inner-spin-button, 
      input[type=number]::-webkit-outer-spin-button { 
        -webkit-appearance: none; margin: 0; 
      }
      input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
      input[type=range]::-webkit-slider-thumb {
        -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px;
      }
      input[type=range]::-webkit-slider-runnable-track {
        width: 100%; height: 4px; cursor: pointer; background: #e5e7eb; border-radius: 2px;
      }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef } = React;

      // --- å›¾æ ‡ç»„ä»¶ ---
      const IconUpload = () => (<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>);
      const IconTrash = () => (<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>);
      const IconSettings = () => (<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>);

      // --- 3D è¾…åŠ©å‡½æ•° ---
      const createTextSprite = (message, scaleSize) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const res = 4; 
        canvas.width = 128 * res;
        canvas.height = 64 * res;
        
        ctx.fillStyle = "rgba(0,0,0,0)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = `bold ${24 * res}px Arial, sans-serif`; 
        ctx.fillStyle = "#dc2626"; 
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(message, canvas.width / 2, canvas.height / 2);
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.minFilter = THREE.LinearFilter;
        
        const material = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false });
        const sprite = new THREE.Sprite(material);
        
        sprite.scale.set(scaleSize * 2, scaleSize, 1);
        sprite.renderOrder = 999;
        return sprite;
      };

      const createDimensionLine = (start, end, offsetDir, labelText, dynamicScale) => {
          const group = new THREE.Group();
          
          // è®¡ç®—åç§»é‡
          const offsetVec = offsetDir.clone().normalize().multiplyScalar(dynamicScale.offset);

          const p1 = start.clone().add(offsetVec);
          const p2 = end.clone().add(offsetVec);
          
          const lineMat = new THREE.LineBasicMaterial({ color: 0xdc2626 });
          const refMat = new THREE.LineBasicMaterial({ color: 0xdc2626, opacity: 0.15, transparent: true });

          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([p1, p2]), lineMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([start, p1]), refMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([end, p2]), refMat));

          const tickSize = dynamicScale.tick; 
          const dir = new THREE.Vector3().subVectors(p2, p1).normalize();
          let tickDir = new THREE.Vector3(0, 1, 0); 
          if (Math.abs(dir.y) > 0.9) tickDir = new THREE.Vector3(1, 0, 0);
          
          const t1_a = p1.clone().add(tickDir.clone().multiplyScalar(tickSize/2));
          const t1_b = p1.clone().sub(tickDir.clone().multiplyScalar(tickSize/2));
          const t2_a = p2.clone().add(tickDir.clone().multiplyScalar(tickSize/2));
          const t2_b = p2.clone().sub(tickDir.clone().multiplyScalar(tickSize/2));
          
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t1_a, t1_b]), lineMat));
          group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([t2_a, t2_b]), lineMat));

          const sprite = createTextSprite(labelText, dynamicScale.text);
          const midPoint = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
          midPoint.add(offsetVec.clone().normalize().multiplyScalar(dynamicScale.text * 0.5));
          sprite.position.copy(midPoint);
          group.add(sprite);
          
          return group;
      };

      // --- 3D åœºæ™¯ç»„ä»¶ ---
      const ThreeScene = ({ dims, labels, textureUrl, textureSettings }) => {
        const mountRef = useRef(null);
        const sceneRef = useRef(null);
        const cameraRef = useRef(null);
        const rendererRef = useRef(null);
        const meshRef = useRef(null);
        const dimsGroupRef = useRef(null);
        
        const [loadedTexture, setLoadedTexture] = useState(null);

        // 1. åˆå§‹åŒ–åœºæ™¯
        useEffect(() => {
          if (!mountRef.current) return;
          const width = mountRef.current.clientWidth;
          const height = mountRef.current.clientHeight;

          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0xeef2f6);
          sceneRef.current = scene;

          const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 2000);
          
          // --- æ ¸å¿ƒä¿®æ”¹ï¼šæ­£å‰æ–¹è§†è§’ï¼Œè·ç¦»æ‹‰è¿‘ ---
          // X=0 (æ­£ä¸­), Y=45 (é€‚åº¦ä¿¯è§†), Z=60 (è·ç¦»æ‹‰è¿‘ï¼Œå¡«æ»¡å±å¹•)
          camera.position.set(0, 45, 60); 
          cameraRef.current = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(width, height);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          renderer.outputEncoding = THREE.sRGBEncoding;
          mountRef.current.appendChild(renderer.domElement);
          rendererRef.current = renderer;

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);
          const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
          dirLight.position.set(50, 100, 50);
          dirLight.castShadow = true;
          dirLight.shadow.mapSize.width = 2048;
          dirLight.shadow.mapSize.height = 2048;
          scene.add(dirLight);
          
          const gridHelper = new THREE.GridHelper(300, 50, 0xccd5ae, 0xe0e0e0);
          gridHelper.position.y = -0.05;
          scene.add(gridHelper);

          const controls = new THREE.OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.maxPolarAngle = Math.PI / 2 - 0.1;

          const geometry = new THREE.BoxGeometry(1, 1, 1);
          const material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
          const cube = new THREE.Mesh(geometry, material);
          cube.castShadow = true;
          cube.receiveShadow = true;
          scene.add(cube);
          meshRef.current = cube;

          const edges = new THREE.LineSegments(
              new THREE.EdgesGeometry(geometry), 
              new THREE.LineBasicMaterial({ color: 0x94a3b8 })
          );
          cube.add(edges);

          const dimsGroup = new THREE.Group();
          scene.add(dimsGroup);
          dimsGroupRef.current = dimsGroup;

          let frameId;
          const animate = () => {
            frameId = requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
          };
          animate();

          const resizeObserver = new ResizeObserver(() => {
              if (!mountRef.current || !renderer || !camera) return;
              const newW = mountRef.current.clientWidth;
              const newH = mountRef.current.clientHeight;
              if (newW > 0) {
                  camera.aspect = newW / newH;
                  camera.updateProjectionMatrix();
                  renderer.setSize(newW, newH);
              }
          });
          resizeObserver.observe(mountRef.current);

          return () => {
            cancelAnimationFrame(frameId);
            resizeObserver.disconnect();
            if (mountRef.current && renderer.domElement) {
              mountRef.current.removeChild(renderer.domElement);
            }
            renderer.dispose();
          };
        }, []);

        // 2. çº¹ç†åŠ è½½
        useEffect(() => {
          if (!textureUrl) {
              setLoadedTexture(null);
              return;
          }
          const loader = new THREE.TextureLoader();
          loader.load(textureUrl, (tex) => {
              tex.encoding = THREE.sRGBEncoding;
              if (rendererRef.current) {
                  tex.anisotropy = rendererRef.current.capabilities.getMaxAnisotropy();
              }
              setLoadedTexture(tex);
          });
        }, [textureUrl]);

        // 3. æ ¸å¿ƒæ›´æ–°é€»è¾‘
        useEffect(() => {
          if (!meshRef.current || !dimsGroupRef.current) return;
          
          const mesh = meshRef.current;
          const scaleFactor = 10; 
          const sx = dims.length / scaleFactor;
          const sy = dims.height / scaleFactor;
          const sz = dims.width / scaleFactor;

          mesh.scale.set(sx, sy, sz);
          mesh.position.y = sy / 2;

          const maxDim = Math.max(sx, sy, sz);
          
          const dynamicScale = {
              text: Math.max(maxDim * 0.06, 2.0),
              offset: maxDim * 0.08 + 2.0,
              tick: Math.max(maxDim * 0.03, 0.5)
          };

          if (loadedTexture) {
              const { mode, scale: texScale } = textureSettings;
              let repL = 1, repW = 1, repH = 1;
              let wrapMode = THREE.ClampToEdgeWrapping;

              if (mode !== 'stretch') {
                  wrapMode = mode === 'mirror' ? THREE.MirroredRepeatWrapping : THREE.RepeatWrapping;
                  repL = dims.length / texScale;
                  repW = dims.width / texScale;
                  repH = dims.height / texScale;
              }

              const getMat = (u, v) => {
                  const t = loadedTexture.clone(); 
                  t.wrapS = wrapMode;
                  t.wrapT = wrapMode;
                  t.repeat.set(u, v);
                  t.needsUpdate = true;
                  return new THREE.MeshStandardMaterial({ map: t, roughness: 0.8 });
              };

              const matSide = getMat(repW, repH);
              const matTop = getMat(repL, repW);
              const matFront = getMat(repL, repH);

              mesh.material = [matSide, matSide, matTop, matTop, matFront, matFront];
              mesh.material.forEach(m => m.needsUpdate = true);
          } else {
              if (Array.isArray(mesh.material)) {
                  mesh.material = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
                  mesh.material.needsUpdate = true;
              }
          }

          const group = dimsGroupRef.current;
          group.clear();
          const halfX = sx / 2;
          const halfZ = sz / 2;
          const groundY = 0.05; 

          // 1. Length (L): åæ–¹
          group.add(createDimensionLine(
              new THREE.Vector3(-halfX, groundY, -halfZ), 
              new THREE.Vector3(halfX, groundY, -halfZ),  
              new THREE.Vector3(0, 0, -1),                
              labels.length,
              dynamicScale
          ));

          // 2. Width (W): å·¦ä¾§
          group.add(createDimensionLine(
              new THREE.Vector3(-halfX, groundY, -halfZ), 
              new THREE.Vector3(-halfX, groundY, halfZ),  
              new THREE.Vector3(-1, 0, 0),                
              labels.width,
              dynamicScale
          ));

          // 3. Height (T): å³ä¾§
          group.add(createDimensionLine(
              new THREE.Vector3(halfX, 0, halfZ),   
              new THREE.Vector3(halfX, sy, halfZ),  
              new THREE.Vector3(1, 0, 0),           
              labels.height,
              dynamicScale
          ));

        }, [dims, labels, loadedTexture, textureSettings]);

        return (
          <div ref={mountRef} className="w-full h-full relative bg-[#eef2f6]"></div>
        );
      };

      const App = () => {
        const [dims, setDims] = useState({ length: 500, width: 300, height: 20 });
        const [labels, setLabels] = useState({ length: 'L', width: 'W', height: 'T' });
        const [textureUrl, setTextureUrl] = useState(null);
        
        const [textureSettings, setTextureSettings] = useState({
            mode: 'stretch', 
            scale: 500       
        });

        const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
                if (textureUrl) URL.revokeObjectURL(textureUrl);
                setTextureUrl(URL.createObjectURL(file));
            }
        };

        return (
          <div className="flex flex-col md:flex-row h-screen w-full bg-white font-sans text-gray-800 overflow-hidden">
            <div className="relative order-1 md:order-2 flex-1 h-[50vh] md:h-full min-w-0">
              <ThreeScene dims={dims} labels={labels} textureUrl={textureUrl} textureSettings={textureSettings} />
              <div className="absolute top-4 left-4 bg-white/90 backdrop-blur px-3 py-2 rounded shadow-sm border border-gray-200 text-xs text-gray-500 pointer-events-none select-none z-10">
                <p className="flex items-center gap-2"><span className="w-2 h-2 rounded-full bg-red-600"></span> çº¢è‰²æ–‡å­—ä¸º 3D æ ‡æ³¨</p>
                <p className="mt-1">ğŸ–±ï¸ å·¦é”®æ—‹è½¬ | å³é”®å¹³ç§» | æ»šè½®ç¼©æ”¾</p>
              </div>
            </div>

            <div className="order-2 md:order-1 w-full md:w-80 flex-shrink-0 bg-white border-r border-gray-200 flex flex-col shadow-xl z-20 h-[50vh] md:h-full">
              <div className="p-4 border-b border-gray-100 flex-shrink-0">
                <h1 className="text-lg font-bold text-gray-800 flex items-center gap-2">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4m0-10L4 7m8 4v10M4 7v10l8 4" /></svg>
                  3Dæ¿æé…ç½®
                </h1>
              </div>
              
              <div className="flex-1 overflow-y-auto p-4 custom-scrollbar">
                <div className="mb-6">
                  <h3 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">å°ºå¯¸ & æ ‡æ³¨</h3>
                  
                  {/* Length */}
                  <div className="mb-3 p-2.5 bg-gray-50 rounded border border-gray-100 hover:border-blue-200 transition-colors">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-600 text-xs font-bold px-1.5 py-0.5 rounded">X</span>
                           <span className="text-xs font-semibold text-gray-600">é•¿åº¦ (Length)</span>
                      </div>
                      <div className="flex gap-2">
                          <div className="flex-1 min-w-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.length} onChange={(e) => setDims({...dims, length: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div className="w-16 flex-shrink-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ ‡æ³¨å­—</label>
                              <input type="text" value={labels.length} onChange={(e) => setLabels({...labels, length: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-red-500 font-bold text-center focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>

                  {/* Width */}
                  <div className="mb-3 p-2.5 bg-gray-50 rounded border border-gray-100 hover:border-blue-200 transition-colors">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-600 text-xs font-bold px-1.5 py-0.5 rounded">Z</span>
                           <span className="text-xs font-semibold text-gray-600">å®½åº¦ (Width)</span>
                      </div>
                      <div className="flex gap-2">
                          <div className="flex-1 min-w-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.width} onChange={(e) => setDims({...dims, width: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div className="w-16 flex-shrink-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ ‡æ³¨å­—</label>
                              <input type="text" value={labels.width} onChange={(e) => setLabels({...labels, width: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-red-500 font-bold text-center focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>

                  {/* Height */}
                  <div className="mb-3 p-2.5 bg-gray-50 rounded border border-gray-100 hover:border-blue-200 transition-colors">
                      <div className="flex items-center gap-2 mb-2">
                           <span className="bg-gray-200 text-gray-600 text-xs font-bold px-1.5 py-0.5 rounded">Y</span>
                           <span className="text-xs font-semibold text-gray-600">é«˜åº¦ (Height)</span>
                      </div>
                      <div className="flex gap-2">
                          <div className="flex-1 min-w-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ•°å€¼ (mm)</label>
                              <input type="number" value={dims.height} onChange={(e) => setDims({...dims, height: Number(e.target.value)})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                          <div className="w-16 flex-shrink-0">
                              <label className="block text-[10px] text-gray-400 mb-0.5">æ ‡æ³¨å­—</label>
                              <input type="text" value={labels.height} onChange={(e) => setLabels({...labels, height: e.target.value})} className="w-full px-2 py-1.5 border border-gray-300 rounded text-sm text-red-500 font-bold text-center focus:ring-2 focus:ring-blue-500 outline-none bg-white" />
                          </div>
                      </div>
                  </div>
                </div>

                <div className="pt-5 border-t border-gray-100 pb-10">
                   <h3 className="text-xs font-bold text-gray-400 uppercase tracking-wider mb-3">è¡¨é¢æè´¨</h3>
                   {!textureUrl ? (
                       <label className="flex flex-col items-center justify-center w-full h-28 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 hover:bg-blue-50 hover:border-blue-300 transition-all group">
                          <div className="flex flex-col items-center justify-center pt-5 pb-6">
                              <div className="text-gray-400 group-hover:text-blue-500 mb-2"><IconUpload /></div>
                              <p className="mb-1 text-xs text-gray-500 group-hover:text-blue-600 font-medium">ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</p>
                              <p className="text-[10px] text-gray-400">æ”¯æŒ JPG, PNG</p>
                          </div>
                          <input type="file" className="hidden" accept="image/*" onChange={handleImageUpload} />
                      </label>
                   ) : (
                       <div className="space-y-4">
                           <div className="relative w-full h-32 rounded-lg overflow-hidden border border-gray-200 group bg-gray-100">
                               <img src={textureUrl} alt="Texture Preview" className="w-full h-full object-cover" />
                               <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                  <button onClick={() => setTextureUrl(null)} className="flex items-center gap-2 bg-white text-red-600 px-3 py-1.5 rounded-full text-xs font-bold shadow hover:bg-red-50">
                                      <IconTrash /> ç§»é™¤
                                  </button>
                               </div>
                           </div>
                           
                           <div className="bg-gray-50 p-3 rounded border border-gray-200">
                              <div className="flex items-center gap-2 mb-3 text-gray-700">
                                  <IconSettings />
                                  <span className="text-xs font-bold">çº¹ç†è®¾ç½®</span>
                              </div>
                              
                              <div className="space-y-3">
                                  <div>
                                      <label className="block text-[10px] text-gray-500 mb-1">é“ºè´´æ¨¡å¼</label>
                                      <select 
                                          value={textureSettings.mode}
                                          onChange={(e) => setTextureSettings({...textureSettings, mode: e.target.value})}
                                          className="w-full text-xs border border-gray-300 rounded px-2 py-1.5 bg-white outline-none focus:border-blue-500"
                                      >
                                          <option value="stretch">â†”ï¸ æ‹‰ä¼¸é“ºæ»¡</option>
                                          <option value="mirror">ğŸª é•œåƒå¹³é“º</option>
                                          <option value="repeat">ğŸ” æ™®é€šå¹³é“º</option>
                                      </select>
                                  </div>

                                  {textureSettings.mode !== 'stretch' && (
                                      <div>
                                          <div className="flex justify-between mb-1">
                                              <label className="block text-[10px] text-gray-500">å•å…ƒå°ºå¯¸</label>
                                              <span className="text-[10px] text-gray-400">{textureSettings.scale}mm</span>
                                          </div>
                                          <input 
                                              type="range" 
                                              min="100" max="2000" step="50"
                                              value={textureSettings.scale}
                                              onChange={(e) => setTextureSettings({...textureSettings, scale: Number(e.target.value)})}
                                              className="w-full h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                          />
                                      </div>
                                  )}
                              </div>
                           </div>
                       </div>
                   )}
                </div>
              </div>
            </div>
          </div>
        );
      };

      const root = ReactDOM.createRoot(document.getElementById('root'));
      root.render(<App />);
    </script>
</body>
</html>
