<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pedal View Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "lucide-react": "https://esm.sh/lucide-react@^0.562.0",
    "uuid": "https://esm.sh/uuid@^13.0.0"
  }
}
</script>
</head>
<body class="bg-slate-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useCallback, useEffect } = React;

        // --- Icons (Inline SVGs to avoid dependency issues in standalone HTML) ---
        const Icon = ({ children, size = 24, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
                {children}
            </svg>
        );
        const Plus = (props) => <Icon {...props}><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></Icon>;
        const Trash2 = (props) => <Icon {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></Icon>;
        const Settings2Icon = (props) => <Icon {...props}><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="18" x2="20" y2="18"></line><circle cx="8" cy="12" r="2"></circle><circle cx="16" cy="6" r="2"></circle><circle cx="16" cy="18" r="2"></circle></Icon>;
        const Download = (props) => <Icon {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></Icon>;
        const Type = (props) => <Icon {...props}><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></Icon>;
        const TriangleIcon = (props) => <Icon {...props}><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path></Icon>;

        // --- Types & Constants ---
        const INITIAL_LAYERS = [
            { id: '1', height: 20, isHatched: false, showMarker: true },
            { id: '2', height: 5, isHatched: true, showMarker: false },
            { id: '3', height: 10, isHatched: false, showMarker: true },
            { id: '4', height: 5, isHatched: true, showMarker: false },
            { id: '5', height: 10, isHatched: false, showMarker: true },
            { id: '6', height: 5, isHatched: true, showMarker: false },
        ];

        const DEFAULT_BORDER = {
            isRed: false,
            showTriangle: false,
            showLeader: false,
            leaderText: '',
        };

        // --- Components ---

        const LayerControl = ({ layer, index, onChange, onRemove }) => {
            const isGapLayer = index % 2 !== 0;

            return (
                <div className="flex items-center gap-2 p-2 bg-white border border-gray-200 rounded-md shadow-sm mb-2 transition-all hover:border-blue-400 group">
                    <span className="text-xs font-mono text-gray-400 w-6">#{index + 1}</span>
                    <div className="flex flex-col flex-1">
                        <input
                            type="number"
                            value={layer.height}
                            onChange={(e) => onChange(layer.id, { height: Number(e.target.value) })}
                            className="w-full border-b border-gray-300 focus:border-blue-500 outline-none py-1 text-sm font-mono"
                        />
                    </div>
                    <div className="flex items-center gap-1 w-16 justify-center">
                        {isGapLayer ? (
                            <span className="text-gray-300">-</span>
                        ) : (
                            <span className="text-gray-300"></span>
                        )}
                    </div>
                    <button
                        onClick={() => onRemove(layer.id)}
                        className="ml-2 text-red-300 hover:text-red-500 transition-colors"
                        title="删除区域"
                    >
                        <Trash2 size={16} />
                    </button>
                </div>
            );
        };

        const CadViewer = ({ config }) => {
            const { length: L, width: W, layers, borders, globalLabels, isFrontPolished } = config;
            
            const PADDING_LEFT = 150; 
            const PADDING_RIGHT = 150; 
            const PADDING_TOP = 100;
            const PADDING_BOTTOM = 100;

            const canvasWidth = L + PADDING_LEFT + PADDING_RIGHT;
            const canvasHeight = W + PADDING_TOP + PADDING_BOTTOM;

            const originX = PADDING_LEFT;
            const originY = PADDING_TOP + W;

            const renderDimensionDot = (x, y) => <circle cx={x} cy={y} r={0.7} fill="red" />;

            const renderBorderTriangle = (x, y, direction) => {
                const size = 5; 
                const height = 6;
                let points = "";
                if (direction === 'down') points = `${x},${y} ${x - size/2},${y - height} ${x + size/2},${y - height}`;
                else if (direction === 'up') points = `${x},${y} ${x - size/2},${y + height} ${x + size/2},${y + height}`;
                else if (direction === 'right') points = `${x},${y} ${x - height},${y - size/2} ${x - height},${y + size/2}`;
                else if (direction === 'left') points = `${x},${y} ${x + height},${y - size/2} ${x + height},${y + size/2}`;
                return <polygon points={points} fill="black" />;
            };

            const renderLeader = (startX, startY, direction, text) => {
                if (!text) return null;
                let path = "", textX = 0, textY = 0, textAnchor = "start";
                const elbowLen = 20, shelfLen = 40;

                if (direction === 'top') {
                    path = `M ${startX} ${startY} L ${startX + elbowLen} ${startY - elbowLen} L ${startX + elbowLen + shelfLen} ${startY - elbowLen}`;
                    textX = startX + elbowLen + 5; textY = startY - elbowLen - 2; textAnchor = "start";
                } else if (direction === 'bottom') {
                    path = `M ${startX} ${startY} L ${startX + elbowLen} ${startY + elbowLen} L ${startX + elbowLen + shelfLen} ${startY + elbowLen}`;
                    textX = startX + elbowLen + 5; textY = startY + elbowLen - 2; textAnchor = "start";
                } else if (direction === 'left') {
                    path = `M ${startX} ${startY} L ${startX - elbowLen} ${startY - elbowLen} L ${startX - elbowLen - shelfLen} ${startY - elbowLen}`;
                    textX = startX - elbowLen - 5; textY = startY - elbowLen - 2; textAnchor = "end";
                } else if (direction === 'right') {
                    path = `M ${startX} ${startY} L ${startX + elbowLen} ${startY - elbowLen} L ${startX + elbowLen + shelfLen} ${startY - elbowLen}`;
                    textX = startX + elbowLen + 5; textY = startY - elbowLen - 2; textAnchor = "start";
                }

                return (
                    <g>
                        {renderDimensionDot(startX, startY)}
                        <path d={path} fill="none" stroke="red" strokeWidth="0.5" />
                        <text x={textX} y={textY} textAnchor={textAnchor} fill="red" fontSize="10" fontFamily="Times New Roman, serif">{text}</text>
                    </g>
                )
            }

            const renderHorizontalDimension = (label, startX, endX, y, color = "red") => (
                <g className="dimension-h">
                    <line x1={startX} y1={y} x2={endX} y2={y} stroke={color} strokeWidth="0.35" />
                    <line x1={startX} y1={y - 2} x2={startX} y2={y + 2} stroke={color} strokeWidth="0.35" />
                    <line x1={endX} y1={y - 2} x2={endX} y2={y + 2} stroke={color} strokeWidth="0.35" />
                    {renderDimensionDot(startX, y)}
                    {renderDimensionDot(endX, y)}
                    <text x={(startX + endX) / 2} y={y - 4} textAnchor="middle" fill={color} fontSize="14" fontFamily="Times New Roman, serif">{label}</text>
                </g>
            );

            const renderVerticalDimension = (label, x, startY, endY, color = "red", offsetText = false) => {
                const midY = (startY + endY) / 2;
                const textOffsetY = offsetText ? -5 : 0; 
                return (
                    <g className="dimension-v">
                        <line x1={x} y1={startY} x2={x} y2={endY} stroke={color} strokeWidth="0.35" />
                        <line x1={x - 2} y1={startY} x2={x + 2} y2={startY} stroke={color} strokeWidth="0.35" />
                        <line x1={x - 2} y1={endY} x2={x + 2} y2={endY} stroke={color} strokeWidth="0.35" />
                        {renderDimensionDot(x, startY)}
                        {renderDimensionDot(x, endY)}
                        <g transform={`translate(${x - 4}, ${midY}) rotate(-90)`}>
                            <text x={0} y={textOffsetY} textAnchor="middle" alignmentBaseline="middle" fill={color} fontSize="12" fontFamily="Times New Roman, serif">{label}</text>
                        </g>
                    </g>
                );
            };

            let currentY = originY;
            const renderedLayers = layers.map((layer, index) => {
                const layerHeight = layer.height;
                const yTop = currentY - layerHeight;
                const yBottom = currentY;
                const isMain = index % 2 === 0;
                const shouldShowMarker = isMain && isFrontPolished;

                const el = (
                    <g key={layer.id}>
                        <rect x={originX} y={yTop} width={L} height={layerHeight} fill={layer.isHatched ? "url(#diagonalHatch)" : "white"} stroke="black" strokeWidth="0.5" />
                        {shouldShowMarker && (
                            <polygon points={`${originX + L/2 - 2},${yTop + layerHeight/2 - 2} ${originX + L/2 + 2},${yTop + layerHeight/2 - 2} ${originX + L/2},${yTop + layerHeight/2 + 2}`} fill="black" />
                        )}
                        <line x1={originX} y1={yTop} x2={originX - (index % 2 === 0 ? 35 : 55)} y2={yTop} stroke="red" strokeWidth="0.25" strokeOpacity="0.5" />
                        <line x1={originX} y1={yBottom} x2={originX - (index % 2 === 0 ? 35 : 55)} y2={yBottom} stroke="red" strokeWidth="0.25" strokeOpacity="0.5" />
                        {renderVerticalDimension(layer.height, originX - (index % 2 === 0 ? 30 : 50), yTop, yBottom, "red")}
                    </g>
                );
                currentY = yTop;
                return el;
            });

            const topStackY = currentY;
            const topBorderY = originY - W;
            const remainingSpace = topStackY - topBorderY;

            return (
                <div className="w-full h-full bg-white overflow-hidden flex items-center justify-center p-4 border border-gray-200 rounded-lg shadow-inner">
                    <svg width="100%" height="100%" viewBox={`0 0 ${canvasWidth} ${canvasHeight}`} preserveAspectRatio="xMidYMid meet" className="max-h-[80vh]">
                        <defs>
                            <pattern id="diagonalHatch" patternUnits="userSpaceOnUse" width="6" height="6" patternTransform="rotate(45)">
                                <line x1="0" y1="0" x2="0" y2="6" stroke="black" strokeWidth="0.5" />
                            </pattern>
                        </defs>
                        <rect width={canvasWidth} height={canvasHeight} fill="white" />
                        {renderedLayers}
                        {remainingSpace > 10 && isFrontPolished && (
                            <polygon points={`${originX + L/2 - 2},${topBorderY + remainingSpace/2 - 2} ${originX + L/2 + 2},${topBorderY + remainingSpace/2 - 2} ${originX + L/2},${topBorderY + remainingSpace/2 + 2}`} fill="black" />
                        )}
                        <line x1={originX} y1={originY - W} x2={originX + L} y2={originY - W} stroke={borders.top.isRed ? "red" : "black"} strokeWidth="0.75" />
                        {borders.top.showTriangle && renderBorderTriangle(originX + L/2, originY - W - 2, 'down')}
                        {borders.top.showLeader && renderLeader(originX + L/2 + 30, originY - W, 'top', borders.top.leaderText)}
                        <line x1={originX} y1={originY} x2={originX + L} y2={originY} stroke={borders.bottom.isRed ? "red" : "black"} strokeWidth="0.75" />
                        {borders.bottom.showTriangle && renderBorderTriangle(originX + L/2, originY + 2, 'up')}
                        {borders.bottom.showLeader && renderLeader(originX + L/2 + 30, originY, 'bottom', borders.bottom.leaderText)}
                        <line x1={originX} y1={originY - W} x2={originX} y2={originY} stroke={borders.left.isRed ? "red" : "black"} strokeWidth="0.75" />
                        {borders.left.showTriangle && renderBorderTriangle(originX - 2, originY - W/2, 'right')}
                        {borders.left.showLeader && renderLeader(originX, originY - W/2 - 30, 'left', borders.left.leaderText)}
                        <line x1={originX + L} y1={originY - W} x2={originX + L} y2={originY} stroke={borders.right.isRed ? "red" : "black"} strokeWidth="0.75" />
                        {borders.right.showTriangle && renderBorderTriangle(originX + L + 2, originY - W/2, 'left')}
                        {borders.right.showLeader && renderLeader(originX + L, originY - W/2 - 30, 'right', borders.right.leaderText)}
                        <line x1={originX} y1={originY - W} x2={originX} y2={originY - W - 60} stroke="red" strokeWidth="0.35" />
                        <line x1={originX + L} y1={originY - W} x2={originX + L} y2={originY - W - 60} stroke="red" strokeWidth="0.35" />
                        {renderHorizontalDimension(globalLabels.L || "L", originX, originX + L, originY - W - 55)}
                        <line x1={originX} y1={originY - W} x2={originX - 85} y2={originY - W} stroke="red" strokeWidth="0.35" />
                        <line x1={originX} y1={originY} x2={originX - 85} y2={originY} stroke="red" strokeWidth="0.35" />
                        {renderVerticalDimension(globalLabels.W || "W", originX - 80, originY - W, originY, "red", true)}
                    </svg>
                </div>
            );
        };

        const App = () => {
            const [length, setLength] = useState(400);
            const [width, setWidth] = useState(150);
            const [isFrontPolished, setIsFrontPolished] = useState(true);
            const [globalLabels, setGlobalLabels] = useState({ L: 'L', W: 'W' });
            const [layers, setLayers] = useState(INITIAL_LAYERS);
            
            const [borders, setBorders] = useState({
                top: { ...DEFAULT_BORDER, leaderText: '倒角3mm' },
                bottom: { ...DEFAULT_BORDER, leaderText: '倒角3mm' },
                left: { ...DEFAULT_BORDER, leaderText: '倒角3mm' },
                right: { ...DEFAULT_BORDER, leaderText: '倒角3mm' },
            });

            const handleLayerChange = (id, updates) => {
                setLayers(prev => prev.map(layer => {
                    if (layer.id !== id) return layer;
                    const newLayer = { ...layer, ...updates };
                    if (updates.showMarker === true) newLayer.isHatched = false;
                    if (updates.isHatched === true) newLayer.showMarker = false;
                    return newLayer;
                }));
            };

            const handleRemoveLayer = (id) => {
                setLayers(prev => prev.filter(layer => layer.id !== id));
            };

            const handleAddLayer = () => {
                setLayers(prev => {
                    const nextIndex = prev.length;
                    const isGap = nextIndex % 2 !== 0; 
                    const newLayer = {
                        id: window.uuid ? window.uuid.v4() : Math.random().toString(36).substr(2, 9),
                        height: isGap ? 5 : 10,
                        isHatched: isGap,
                        showMarker: !isGap 
                    };
                    return [...prev, newLayer];
                });
            };

            const updateBorder = (side, updates) => {
                setBorders(prev => {
                    const newState = { ...prev[side], ...updates };
                    if (newState.showTriangle || newState.showLeader) {
                        newState.isRed = true;
                    } else {
                        newState.isRed = false;
                    }
                    return { ...prev, [side]: newState };
                });
            };

            const config = { length, width, isFrontPolished, globalLabels, layers, borders };
            const totalLayerHeight = layers.reduce((sum, l) => sum + l.height, 0);

            const renderBorderControl = (side, label) => {
                const b = borders[side];
                return (
                    <div className="bg-gray-50 p-3 rounded-lg border border-gray-100 space-y-2">
                        <div className="flex items-center justify-between">
                            <span className="text-xs font-bold text-gray-700">{label}</span>
                        </div>
                        <div className="flex items-center gap-2">
                            <button 
                                onClick={() => updateBorder(side, { showTriangle: !b.showTriangle })}
                                className={`p-1.5 rounded flex-1 flex items-center justify-center gap-1 text-[10px] border ${b.showTriangle ? 'bg-black text-white border-black' : 'bg-white text-gray-500 border-gray-200'}`}
                            >
                                <TriangleIcon size={10} className={b.showTriangle ? 'fill-white' : ''} /> 磨光
                            </button>
                            <button 
                                onClick={() => updateBorder(side, { showLeader: !b.showLeader })}
                                className={`p-1.5 rounded flex-1 flex items-center justify-center gap-1 text-[10px] border ${b.showLeader ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-500 border-gray-200'}`}
                            >
                                <Type size={10} /> 倒角
                            </button>
                        </div>
                        {b.showLeader && (
                            <input 
                                type="text" 
                                value={b.leaderText}
                                onChange={(e) => updateBorder(side, { leaderText: e.target.value })}
                                className="w-full text-xs p-1 border border-gray-300 rounded"
                                placeholder="引线文字"
                            />
                        )}
                    </div>
                );
            };

            return (
                <div className="min-h-screen bg-slate-50 flex flex-col md:flex-row font-sans text-slate-800">
                    <aside className="w-full md:w-96 bg-white border-r border-gray-200 flex flex-col h-screen max-h-screen overflow-hidden shadow-xl z-10">
                        <div className="p-5 border-b border-gray-200 bg-white text-black">
                            <h1 className="text-xl font-bold flex items-center gap-2">
                                <Settings2Icon size={24} className="text-black" />
                                踏板俯视图生成器
                            </h1>
                            <p className="text-xs text-gray-500 mt-1">尺寸与样式配置</p>
                        </div>
                        <div className="flex-1 overflow-y-auto p-5 space-y-6">
                            <section className="space-y-4">
                                <h2 className="text-sm font-bold text-slate-900 uppercase tracking-wider">全局尺寸</h2>
                                <div className="grid grid-cols-2 gap-4">
                                    <div className="space-y-1">
                                        <label className="text-xs font-semibold text-gray-500">长度</label>
                                        <div className="flex gap-1">
                                            <input type="number" value={length} onChange={(e) => setLength(Number(e.target.value))} className="w-2/3 p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 outline-none text-xs" />
                                            <input type="text" value={globalLabels.L} onChange={(e) => setGlobalLabels(prev => ({...prev, L: e.target.value}))} className="w-1/3 p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 outline-none text-xs text-center" placeholder="L" />
                                        </div>
                                    </div>
                                    <div className="space-y-1">
                                        <label className="text-xs font-semibold text-gray-500">总宽度</label>
                                        <div className="flex gap-1">
                                            <input type="number" value={width} onChange={(e) => setWidth(Number(e.target.value))} className={`w-2/3 p-2 border rounded focus:ring-2 focus:ring-blue-500 outline-none text-xs ${width < totalLayerHeight ? 'border-orange-300 bg-orange-50' : 'border-gray-300'}`} />
                                            <input type="text" value={globalLabels.W} onChange={(e) => setGlobalLabels(prev => ({...prev, W: e.target.value}))} className="w-1/3 p-2 border border-gray-300 rounded focus:ring-2 focus:ring-blue-500 outline-none text-xs text-center" placeholder="W" />
                                        </div>
                                    </div>
                                </div>
                                {width < totalLayerHeight && <div className="text-xs text-orange-600 bg-orange-100 p-2 rounded">注意: 总宽度 ({width}) 小于分段总和 ({totalLayerHeight})</div>}
                                
                                <div className="mt-2 bg-gray-50 p-2 rounded border border-gray-200">
                                    <label className="flex items-center gap-2 cursor-pointer">
                                        <input type="checkbox" checked={isFrontPolished} onChange={(e) => setIsFrontPolished(e.target.checked)} className="rounded text-black focus:ring-gray-500" />
                                        <span className="text-xs font-semibold text-gray-700">正面磨光</span>
                                    </label>
                                </div>

                                <div className="pt-2">
                                    <div className="text-xs font-semibold text-gray-500 mb-2">边框设置 (磨光/倒角)</div>
                                    <div className="grid grid-cols-2 gap-3">
                                        {renderBorderControl('top', '上L')}
                                        {renderBorderControl('bottom', '下L')}
                                        {renderBorderControl('left', '左W')}
                                        {renderBorderControl('right', '右W')}
                                    </div>
                                </div>
                            </section>

                            <hr className="border-gray-100" />

                            <section className="space-y-3">
                                <div className="flex justify-between items-end">
                                    <span className="text-xs text-gray-400 font-mono ml-auto">总和: {totalLayerHeight}</span>
                                </div>
                                
                                <button onClick={handleAddLayer} className="w-full py-2 border-2 border-dashed border-gray-300 rounded-lg text-gray-500 hover:border-blue-500 hover:text-blue-500 flex items-center justify-center gap-2 transition-all mb-2 text-sm font-medium">
                                    <Plus size={16} /> 添加区域
                                </button>

                                <div className="space-y-2">
                                    {[...layers].reverse().map((layer, reverseIndex) => {
                                        const originalIndex = layers.length - 1 - reverseIndex;
                                        return (
                                            <LayerControl
                                                key={layer.id}
                                                index={originalIndex}
                                                layer={layer}
                                                isTotalLast={originalIndex === layers.length - 1}
                                                onChange={handleLayerChange}
                                                onRemove={handleRemoveLayer}
                                            />
                                        );
                                    })}
                                </div>
                            </section>
                        </div>
                        <div className="p-4 bg-gray-50 border-t border-gray-200 text-center text-xs text-gray-400">
                            Generated via Gemini React Engine
                        </div>
                    </aside>

                    <main className="flex-1 p-6 md:p-10 flex flex-col h-screen max-h-screen overflow-hidden">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-2xl font-bold text-slate-800">图纸预览</h2>
                            <button className="px-4 py-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700 transition-colors flex items-center gap-2 text-sm" onClick={() => window.print()}>
                                <Download size={16} /> 导出 / 打印
                            </button>
                        </div>
                        <div className="flex-1 min-h-0 relative">
                            <CadViewer config={config} />
                        </div>
                    </main>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
