<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扇形板</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        .polish-btn {
            background-color: white;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        .polish-btn.active {
            background-color: #374151;
            color: white;
            border-color: #374151;
            font-weight: 600;
        }
        .polish-btn:not(.active):hover {
            background-color: #f9fafb;
        }
        .input-wrapper { position: relative; }
        
        .custom-checkbox {
            accent-color: #374151;
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        
        /* 分组标题样式 */
        .group-label {
            grid-column: span 2;
            font-size: 11px;
            font-weight: 700;
            color: #9ca3af;
            text-transform: uppercase;
            margin-top: 8px;
            margin-bottom: 4px;
            letter-spacing: 0.05em;
        }
    </style>
</head>
<body class="bg-gray-50 text-slate-800 min-h-screen flex flex-col lg:flex-row justify-center items-stretch gap-4 p-6">

    <!-- 左侧控制面板 -->
    <div class="w-full lg:w-96 flex-shrink-0 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col overflow-y-auto max-h-screen">
        <div class="flex items-center justify-between mb-4 border-b pb-3">
            <h1 class="font-bold text-lg text-gray-800">扇形板计算器</h1>
            <button onclick="resetParams()" class="text-xs text-gray-600 flex items-center gap-1 hover:bg-gray-100 px-2 py-1 rounded transition-colors">
                <i data-lucide="rotate-ccw" width="12"></i> 重置
            </button>
        </div>

        <div class="space-y-4 flex-1">
            <!-- 几何参数 -->
            <div>
                <div class="flex justify-between items-end mb-2">
                    <label class="text-xs font-bold text-gray-500">输入任意参数 (自动互推)</label>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <!-- 基础尺寸 -->
                    <div class="group-label">基础尺寸</div>
                    <div class="input-wrapper">
                        <input type="number" id="radiusOut" value="2000" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外半径 (R外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="radiusIn" value="1200" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内半径 (R内)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="widthVal" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">宽度 (W)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="thickness" value="30" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">厚度 (T)</span>
                    </div>

                    <!-- 弧长与弦长 -->
                    <div class="group-label">弧长与弦长</div>
                    <div class="input-wrapper">
                        <input type="number" id="arcOut" value="1500" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外弧长 (L外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="arcIn" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内弧长 (L内)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="chordOut" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外弦长 (C外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="chordIn" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内弦长 (C内)</span>
                    </div>

                    <!-- 高度参数 -->
                    <div class="group-label">高度参数 (支持反推)</div>
                    <div class="input-wrapper">
                        <input type="number" id="archOut" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外弧拱高 (h外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="archIn" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内弧拱高 (h内)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="totalHeight" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">总高 (H)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="sideVertHeight" placeholder="自动" class="geom-input w-full h-11 px-3 pt-5 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">侧边垂高 (Hv)</span>
                    </div>
                </div>
                <div id="statusMsg" class="mt-2 text-xs flex items-start gap-1 text-gray-500 font-medium"></div>
            </div>

            <!-- 磨光面标记 -->
            <div class="pt-2 border-t border-gray-100">
                <label class="text-xs font-bold text-gray-400 uppercase mb-2 block">磨光面标记</label>
                <div class="grid grid-cols-3 gap-2">
                    <button class="polish-btn active flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('face', this)">正面</button>
                    <button class="polish-btn flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('waiHu', this)">外弧面</button>
                    <button class="polish-btn flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('neiHu', this)">内弧面</button>
                    <button class="polish-btn flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('leftSide', this)">左侧面</button>
                    <button class="polish-btn flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('rightSide', this)">右侧面</button>
                    <button class="polish-btn flex items-center justify-center p-1.5 rounded text-xs transition-all" onclick="togglePolish('back', this)">背面</button>
                </div>
            </div>

             <!-- 显示选项 -->
             <div class="pt-2 border-t border-gray-100">
                <label class="text-xs font-bold text-gray-400 uppercase mb-2 block">图纸标注选项</label>
                <div class="grid grid-cols-2 gap-2">
                    <label class="flex items-center space-x-2 text-xs cursor-pointer select-none hover:text-gray-900 text-gray-600">
                        <input type="checkbox" id="showArchHeight" onchange="draw()" class="custom-checkbox rounded border-gray-300">
                        <span>显示拱高</span>
                    </label>
                    <label class="flex items-center space-x-2 text-xs cursor-pointer select-none hover:text-gray-900 text-gray-600">
                        <input type="checkbox" id="showTotalHeight" onchange="draw()" checked class="custom-checkbox rounded border-gray-300">
                        <span>显示总高</span>
                    </label>
                    <label class="flex items-center space-x-2 text-xs cursor-pointer select-none hover:text-gray-900 text-gray-600 col-span-2">
                        <input type="checkbox" id="showSideVertHeight" onchange="draw()" checked class="custom-checkbox rounded border-gray-300">
                        <span>显示侧边垂高 (上弧底-下弧底)</span>
                    </label>
                </div>
            </div>

            <!-- 计算结果 -->
            <div id="resultBox" class="hidden mt-2 bg-gray-50 rounded-lg p-3 border border-gray-200 text-xs">
                <h3 class="font-bold text-gray-700 mb-2 flex items-center gap-1">
                    <i data-lucide="calculator" width="12"></i> 计算结果
                </h3>
                <div class="flex flex-col space-y-1" id="resultContent"></div>
            </div>
        </div>
    </div>

    <!-- 右侧预览面板 -->
    <div class="flex-1 bg-white rounded-xl shadow-sm border border-gray-200 p-4 flex flex-col min-h-[600px] max-w-5xl relative">
        <div class="flex justify-between items-center mb-2 border-b pb-2 z-10 bg-white">
            <h2 class="font-bold text-gray-700 flex items-center gap-2">
                预览图 <span class="text-xs font-normal text-white bg-gray-400 px-2 py-0.5 rounded-full">自动适应</span>
            </h2>
            <button id="downloadBtn" onclick="downloadImage()" disabled class="text-xs bg-gray-800 text-white flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-900 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors">
                <i data-lucide="download" width="14"></i> 下载图纸
            </button>
        </div>
        <div id="svgContainer" class="flex-1 w-full h-full flex items-center justify-start overflow-hidden bg-white"></div>
    </div>

    <script>
        lucide.createIcons();

        const state = {
            polish: {
                face: true,
                back: false, 
                waiHu: false,
                neiHu: false,
                leftSide: false,
                rightSide: false
            },
            data: null
        };

        document.querySelectorAll('.geom-input').forEach(input => {
            input.addEventListener('input', calculate);
        });

        function togglePolish(key, btn) {
            state.polish[key] = !state.polish[key];
            if (state.polish[key]) btn.classList.add('active');
            else btn.classList.remove('active');
            draw();
        }

        function resetParams() {
            const ids = ['radiusOut', 'radiusIn', 'widthVal', 'arcOut', 'arcIn', 'chordOut', 'chordIn', 'archOut', 'archIn', 'totalHeight', 'sideVertHeight'];
            ids.forEach(id => document.getElementById(id).value = '');
            
            document.getElementById('radiusOut').value = '2000';
            document.getElementById('radiusIn').value = '1200';
            document.getElementById('arcOut').value = '1500';
            document.getElementById('thickness').value = '30';
            calculate();
        }

        function calculate() {
            const getVal = (id) => {
                const v = parseFloat(document.getElementById(id).value);
                return isNaN(v) ? null : v;
            };

            let inp = {
                ro: getVal('radiusOut'),
                ri: getVal('radiusIn'),
                w:  getVal('widthVal'),
                lo: getVal('arcOut'),
                li: getVal('arcIn'),
                co: getVal('chordOut'),
                ci: getVal('chordIn'),
                ho: getVal('archOut'),
                hi: getVal('archIn'),
                ht: getVal('totalHeight'),
                hsv: getVal('sideVertHeight'),
                t:  getVal('thickness')
            };

            const statusEl = document.getElementById('statusMsg');
            const resultBox = document.getElementById('resultBox');
            const downloadBtn = document.getElementById('downloadBtn');

            if (!inp.t) {
                showError("请输入板厚度");
                return;
            }

            // --- 参数推导逻辑 ---
            
            // 1. 基础几何: H_total = W + h_in
            if (inp.ht && inp.w && !inp.hi) inp.hi = inp.ht - inp.w;
            if (inp.ht && inp.hi && !inp.w) inp.w = inp.ht - inp.hi;
            if (inp.w && inp.hi && !inp.ht) inp.ht = inp.w + inp.hi;

            // 2. 基础几何: R, r, W
            if (inp.ro && inp.ri && !inp.w) inp.w = inp.ro - inp.ri;
            if (inp.ro && inp.w && !inp.ri) inp.ri = inp.ro - inp.w;
            if (inp.ri && inp.w && !inp.ro) inp.ro = inp.ri + inp.w;

            let theta = null;

            // 3. 角度推导 (新增高级反推)
            
            // 场景: 侧边垂高 + 宽度 -> 角度
            if (!theta && inp.w && inp.hsv && inp.hsv <= inp.w) {
                theta = 2 * Math.acos(inp.hsv / inp.w);
            }

            // 场景: 弦长 + 拱高 -> 半径 + 角度 (外弧)
            if (!theta && !inp.ro && inp.ho && inp.co) {
                inp.ro = (inp.co * inp.co + 4 * inp.ho * inp.ho) / (8 * inp.ho);
                theta = 2 * Math.asin(inp.co / (2 * inp.ro));
            }
            // 场景: 弦长 + 拱高 -> 半径 + 角度 (内弧)
            if (!theta && !inp.ri && inp.hi && inp.ci) {
                inp.ri = (inp.ci * inp.ci + 4 * inp.hi * inp.hi) / (8 * inp.hi);
                theta = 2 * Math.asin(inp.ci / (2 * inp.ri));
            }

            // 场景: 半径 + 拱高 -> 角度
            if (!theta && inp.ro && inp.ho) {
                let cosVal = 1 - inp.ho/inp.ro;
                if (cosVal >= -1 && cosVal <= 1) theta = 2 * Math.acos(cosVal);
            }
            if (!theta && inp.ri && inp.hi) {
                let cosVal = 1 - inp.hi/inp.ri;
                if (cosVal >= -1 && cosVal <= 1) theta = 2 * Math.acos(cosVal);
            }

            // 4. 常规角度推导
            if (!theta && inp.lo && inp.ro) theta = inp.lo / inp.ro;
            if (!theta && inp.li && inp.ri) theta = inp.li / inp.ri;

            if (!theta && inp.co && inp.ro) {
                if (inp.co <= 2 * inp.ro) theta = 2 * Math.asin(inp.co / (2 * inp.ro));
            }
            if (!theta && inp.ci && inp.ri) {
                if (inp.ci <= 2 * inp.ri) theta = 2 * Math.asin(inp.ci / (2 * inp.ri));
            }

            if (!theta && inp.lo && inp.li && inp.w) {
                 theta = (inp.lo - inp.li) / inp.w;
            }

            // 5. 有了角度后，补全半径
            if (theta && theta > 0) {
                if (!inp.ro) {
                    if (inp.lo) inp.ro = inp.lo / theta;
                    else if (inp.co) inp.ro = inp.co / (2 * Math.sin(theta/2));
                }
                if (!inp.ri) {
                    if (inp.li) inp.ri = inp.li / theta;
                    else if (inp.ci) inp.ri = inp.ci / (2 * Math.sin(theta/2));
                }
            }

            if (!inp.w && inp.ro && inp.ri) inp.w = inp.ro - inp.ri;
            if (inp.w && !inp.ri && inp.ro) inp.ri = inp.ro - inp.w;

            // 6. 验证与结果生成
            let error = null;
            let ro = inp.ro;
            let ri = inp.ri;

            if (!theta) {
                if ((ro || ri) && !inp.lo && !inp.li && !inp.co && !inp.ci && !inp.ho && !inp.hi && !inp.hsv) error = "请输入更多参数以确定形状";
                else if (inp.lo && inp.li && !inp.w && !ro && !ri) error = "请输入 [宽度] 或 [半径] 以计算";
                else error = "参数不足，无法构建图形";
            } else {
                if (!ro && !ri) error = "无法确定半径";
                else if (ro && ri && ro <= ri) error = "外半径必须大于内半径";
                else if (theta > Math.PI * 2) error = "角度过大 (>360°)";
            }

            if (!error) {
                const cosHalf = Math.cos(theta/2);
                const h_out = ro * (1 - cosHalf);
                const h_in = ri * (1 - cosHalf);
                const h_total = ro - (ri * cosHalf);
                const h_side_vert = (ro - ri) * cosHalf;

                const res = {
                    ro: ro, ri: ri,
                    lo: theta * ro, li: theta * ri,
                    co: 2 * ro * Math.sin(theta/2), ci: 2 * ri * Math.sin(theta/2),
                    w: ro - ri, angle: theta * 180 / Math.PI, t: inp.t,
                    ho: h_out, hi: h_in, ht: h_total, hsv: h_side_vert
                };
                state.data = { valid: true, theta: theta, ...res };

                statusEl.innerHTML = `<i data-lucide="check-circle-2" width="12"></i> 生成成功`;
                statusEl.className = "mt-2 text-xs flex items-center gap-1 text-gray-700 font-medium";
                resultBox.classList.remove('hidden');
                
                const fmt = (n) => n.toFixed(1);
                // 辅助函数：如果输入框为空，则显示为粗体（表示是计算出的）
                const isAuto = (val, id) => {
                    const el = document.getElementById(id);
                    return (el && el.value == '') ? 'font-mono font-bold text-gray-900' : 'font-mono text-gray-700';
                };
                
                // 填充结果列表
                document.getElementById('resultContent').innerHTML = `
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">侧边宽(W)</span> <span class="${isAuto(res.w, 'widthVal')}">${fmt(res.w)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">圆心角</span> <span class="font-mono text-gray-900">${fmt(res.angle)}°</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">总高度</span> <span class="${isAuto(res.ht, 'totalHeight')}">${fmt(res.ht)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">侧边垂高</span> <span class="${isAuto(res.hsv, 'sideVertHeight')}">${fmt(res.hsv)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">外弧拱高</span> <span class="${isAuto(res.ho, 'archOut')}">${fmt(res.ho)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">内弧拱高</span> <span class="${isAuto(res.hi, 'archIn')}">${fmt(res.hi)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">外弦长</span> <span class="${isAuto(res.co, 'chordOut')}">${fmt(res.co)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">内弦长</span> <span class="${isAuto(res.ci, 'chordIn')}">${fmt(res.ci)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">外弧长</span> <span class="${isAuto(res.lo, 'arcOut')}">${fmt(res.lo)}</span></div>
                    <div class="flex justify-between"><span class="text-gray-400">内弧长</span> <span class="${isAuto(res.li, 'arcIn')}">${fmt(res.li)}</span></div>
                `;
                downloadBtn.disabled = false;
                lucide.createIcons();
                draw();
            } else {
                showError(error || "请输入参数");
            }
        }

        function showError(msg) {
            state.data = { valid: false };
            const statusEl = document.getElementById('statusMsg');
            statusEl.innerHTML = `<i data-lucide="alert-circle" width="12"></i> ${msg}`;
            statusEl.className = "mt-2 text-xs flex items-center gap-1 text-gray-800 font-medium";
            document.getElementById('resultBox').classList.add('hidden');
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('svgContainer').innerHTML = `
                <div class="text-center text-gray-300">
                    <i data-lucide="box" class="mx-auto mb-2 w-12 h-12 opacity-20"></i>
                    <p>${msg}</p>
                </div>
            `;
            lucide.createIcons();
        }

        function downloadImage() {
            const svg = document.getElementById('mainSvg');
            if (!svg) return;
            const serializer = new XMLSerializer();
            const source = serializer.serializeToString(svg);
            const blob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fan_plate_${new Date().getTime()}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        function draw() {
            if (!state.data || !state.data.valid) return;
            const { theta, ro: R_out, ri: R_in, t: T, lo: L_out, li: L_in, co: C_out, ci: C_in, w: W, ho: H_out, hi: H_in, ht: H_total, hsv: H_side_vert } = state.data;

            const showArch = document.getElementById('showArchHeight').checked;
            const showTotal = document.getElementById('showTotalHeight').checked;
            const showSideVert = document.getElementById('showSideVertHeight').checked;

            const polarToCartesian = (r, angle) => ({
                x: r * Math.sin(angle),
                y: -r * Math.cos(angle)
            });

            const startAngle = -theta / 2;
            const endAngle = theta / 2;

            const p_out_left = polarToCartesian(R_out, startAngle);
            const p_out_right = polarToCartesian(R_out, endAngle);
            const p_in_left = polarToCartesian(R_in, startAngle);
            const p_in_right = polarToCartesian(R_in, endAngle);

            // 3D 投影 (厚度)
            const depthAngle = 45 * Math.PI / 180;
            const depthLen = T * 0.8; 
            const dx = depthLen * Math.sin(depthAngle);
            const dy = -depthLen * Math.cos(depthAngle);
            const project = (p) => ({ x: p.x + dx, y: p.y + dy });

            const p_out_left_back = project(p_out_left);
            const p_out_right_back = project(p_out_right);
            const p_in_right_back = project(p_in_right);
            const p_in_left_back = project(p_in_left);

            // 路径定义
            const pathFace = `M ${p_out_left.x} ${p_out_left.y} A ${R_out} ${R_out} 0 0 1 ${p_out_right.x} ${p_out_right.y} L ${p_in_right.x} ${p_in_right.y} A ${R_in} ${R_in} 0 0 0 ${p_in_left.x} ${p_in_left.y} Z`;
            const pathOuter = `M ${p_out_left.x} ${p_out_left.y} L ${p_out_left_back.x} ${p_out_left_back.y} A ${R_out} ${R_out} 0 0 1 ${p_out_right_back.x} ${p_out_right_back.y} L ${p_out_right.x} ${p_out_right.y} A ${R_out} ${R_out} 0 0 0 ${p_out_left.x} ${p_out_left.y} Z`;
            const pathRight = `M ${p_out_right.x} ${p_out_right.y} L ${p_out_right_back.x} ${p_out_right_back.y} L ${p_in_right_back.x} ${p_in_right_back.y} L ${p_in_right.x} ${p_in_right.y} Z`;

            const colorWhite = "#ffffff";
            const colorPolish = "#e5e7eb"; 
            
            // 尺寸标注坐标计算
            const top_apex_y = -R_out;
            const top_chord_y = top_apex_y - 40;
            
            const dim_arc_r = R_out + 120;
            const p_arc_start = polarToCartesian(dim_arc_r, startAngle);
            const p_arc_end = polarToCartesian(dim_arc_r, endAngle);
            const p_text_arc = polarToCartesian(dim_arc_r + 5, 0); 

            const dim_arc_in_r = R_in - 50;
            const p_arc_in_start = polarToCartesian(dim_arc_in_r, startAngle);
            const p_arc_in_end = polarToCartesian(dim_arc_in_r, endAngle);
            const p_text_arc_in = polarToCartesian(dim_arc_in_r - 10, 0);

            const bottom_chord_y = Math.max(p_in_left.y, p_in_right.y) + 140;
            
            // 侧边宽度标注 (Slanted W)
            const left_dx = p_out_left.x - p_in_left.x;
            const left_dy = p_out_left.y - p_in_left.y;
            const len = Math.sqrt(left_dx*left_dx + left_dy*left_dy);
            const nx = left_dy / len; 
            const ny = -left_dx / len;
            const offset_w = 120; 
            const p_w_start = { x: p_out_left.x + nx * offset_w, y: p_out_left.y + ny * offset_w };
            const p_w_end = { x: p_in_left.x + nx * offset_w, y: p_in_left.y + ny * offset_w };
            const p_w_text = { x: (p_w_start.x + p_w_end.x)/2, y: (p_w_start.y + p_w_end.y)/2 };
            const w_angle = Math.atan2(p_w_end.y - p_w_start.y, p_w_end.x - p_w_start.x) * 180 / Math.PI;
            const p_thick_end = p_out_left_back;

            // 磨光面标记
            const markSize = 16;
            const markPath = `M ${-markSize/2} ${-markSize} L ${markSize/2} ${-markSize} L 0 0 Z`;
            let marksSVG = '';

            if (state.polish.face) {
                const r_mid = (R_out + R_in) / 2;
                const p_mid = polarToCartesian(r_mid, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mid.x}, ${p_mid.y})" />`;
            }
            if (state.polish.waiHu) {
                const p_top = polarToCartesian(R_out + 6, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_top.x}, ${p_top.y})" />`;
            }
            if (state.polish.back) {
                const angle_back = 3 * Math.PI / 180;
                const p_base = polarToCartesian(R_out + 4, angle_back);
                const p_back = { x: p_base.x + dx, y: p_base.y + dy }; 
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_back.x}, ${p_back.y}) rotate(30)" />`;
            }
            if (state.polish.neiHu) {
                const p_bot = polarToCartesian(R_in - 6, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_bot.x}, ${p_bot.y}) rotate(180)" />`;
            }
            if (state.polish.leftSide) {
                const r_mid = (R_out + R_in) / 2;
                const p_edge = polarToCartesian(r_mid, startAngle);
                const ang_out = startAngle - Math.PI/2;
                const p_mark = { x: p_edge.x + 1 * Math.sin(ang_out), y: p_edge.y - 1 * Math.cos(ang_out) };
                const rot = (startAngle * 180 / Math.PI) - 90;
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mark.x}, ${p_mark.y}) rotate(${rot})" />`;
            }
            if (state.polish.rightSide) {
                const r_mid = (R_out + R_in) / 2;
                const p_edge = polarToCartesian(r_mid, endAngle);
                const ang_out = endAngle + Math.PI/2;
                const p_mark = { x: p_edge.x + 1 * Math.sin(ang_out), y: p_edge.y - 1 * Math.cos(ang_out) };
                const rot = (endAngle * 180 / Math.PI) + 90;
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mark.x}, ${p_mark.y}) rotate(${rot})" />`;
            }

            // 半径标注函数
            const createRadialDim = (r, angle, text) => {
                const p_start = polarToCartesian(r, angle);
                const p_end = polarToCartesian(r - 150, angle);
                const p_text = polarToCartesian(r - 75, angle);
                const rot = (angle * 180 / Math.PI) + 90;
                return `
                    <circle cx="${p_start.x}" cy="${p_start.y}" r="3" fill="#333" />
                    <line x1="${p_start.x}" y1="${p_start.y}" x2="${p_end.x}" y2="${p_end.y}" stroke="#333" stroke-width="1" />
                    <g transform="translate(${p_text.x}, ${p_text.y}) rotate(${rot})">
                        <text x="0" y="0" text-anchor="middle" dy="-5" font-size="24" fill="#333">${text}</text>
                    </g>
                `;
            };

            const dim_r_out = createRadialDim(R_out, startAngle + theta * 0.15, `R${R_out.toFixed(0)}`);
            const dim_r_in = createRadialDim(R_in, endAngle - theta * 0.15, `R${R_in.toFixed(0)}`);

            // 拱高标注绘制逻辑
            let archHeightSVG = '';
            if (showArch) {
                const p_out_arc_mid = { x: 0, y: -R_out };
                const p_out_chord_mid = { x: 0, y: -R_out * Math.cos(theta/2) };
                const p_in_arc_mid = { x: 0, y: -R_in };
                const p_in_chord_mid = { x: 0, y: -R_in * Math.cos(theta/2) };

                archHeightSVG = `
                    <line x1="0" y1="${p_out_arc_mid.y}" x2="0" y2="${p_out_chord_mid.y}" stroke="#333" stroke-width="1.5" marker-start="url(#arrow-end)" marker-end="url(#arrow-end)" />
                    <text x="5" y="${(p_out_arc_mid.y + p_out_chord_mid.y)/2}" fill="#333" font-size="20" alignment-baseline="middle" font-weight="bold">h${H_out.toFixed(0)}</text>
                    <line x1="0" y1="${p_in_arc_mid.y}" x2="0" y2="${p_in_chord_mid.y}" stroke="#333" stroke-width="1.5" marker-start="url(#arrow-end)" marker-end="url(#arrow-end)" />
                    <text x="5" y="${(p_in_arc_mid.y + p_in_chord_mid.y)/2}" fill="#333" font-size="20" alignment-baseline="middle" font-weight="bold">h${H_in.toFixed(0)}</text>
                `;
            }

            // 总高标注绘制逻辑
            let totalHeightSVG = '';
            if (showTotal) {
                const topY = -R_out;
                const bottomY = -R_in * Math.cos(theta/2);
                const xPos = p_out_right.x + 180; 

                totalHeightSVG = `
                    <line x1="${p_out_right.x}" y1="${topY}" x2="${xPos + 10}" y2="${topY}" stroke="#333" stroke-width="0.5" stroke-dasharray="4,4" />
                    <line x1="${p_in_right.x}" y1="${bottomY}" x2="${xPos + 10}" y2="${bottomY}" stroke="#333" stroke-width="0.5" stroke-dasharray="4,4" />
                    <line x1="${xPos}" y1="${topY}" x2="${xPos}" y2="${bottomY}" stroke="#333" stroke-width="1.5" marker-start="url(#arrow-end)" marker-end="url(#arrow-end)" />
                    <g transform="translate(${xPos + 10}, ${(topY + bottomY)/2}) rotate(90)">
                        <text x="0" y="-5" text-anchor="middle" fill="#333" font-size="26" font-weight="bold">H=${H_total.toFixed(0)}</text>
                    </g>
                `;
            }
            
            // 侧边垂高标注逻辑
            let sideVertHeightSVG = '';
            let sv_min_x = p_out_left.x; 
            if (showSideVert) {
                const y_top = p_out_left.y; 
                const y_bot = p_in_left.y;  
                const x_dim_pos = Math.min(p_out_left.x, p_in_left.x) - 180; 
                sv_min_x = x_dim_pos;

                sideVertHeightSVG = `
                    <line x1="${p_out_left.x}" y1="${y_top}" x2="${x_dim_pos - 10}" y2="${y_top}" stroke="#333" stroke-width="0.5" stroke-dasharray="4,4" />
                    <line x1="${p_in_left.x}" y1="${y_bot}" x2="${x_dim_pos - 10}" y2="${y_bot}" stroke="#333" stroke-width="0.5" stroke-dasharray="4,4" />
                    <line x1="${x_dim_pos}" y1="${y_top}" x2="${x_dim_pos}" y2="${y_bot}" stroke="#333" stroke-width="1.5" marker-start="url(#arrow-end)" marker-end="url(#arrow-end)" />
                    <g transform="translate(${x_dim_pos - 10}, ${(y_top + y_bot)/2}) rotate(-90)">
                        <text x="0" y="-5" text-anchor="middle" fill="#333" font-size="26" font-weight="bold">Hv=${H_side_vert.toFixed(0)}</text>
                    </g>
                `;
            }

            const pointsX = [p_out_left.x, p_out_right.x, p_out_right.x + 200, p_w_start.x - 60, p_thick_end.x - 50, sv_min_x - 50];
            const pointsY = [polarToCartesian(dim_arc_r + 40, 0).y, bottom_chord_y + 50, p_out_right.y];
            const minX = Math.min(...pointsX);
            const maxX = Math.max(...pointsX);
            const minY = Math.min(...pointsY);
            const maxY = Math.max(...pointsY);
            const w_box = maxX - minX;
            const h_box = maxY - minY;
            const padding = 20;
            const viewBox = `${minX - padding} ${minY - padding} ${w_box + 2*padding} ${h_box + 2*padding}`;

            const svg = `
                <svg id="mainSvg" width="100%" height="100%" viewBox="${viewBox}" preserveAspectRatio="xMinYMid meet" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <marker id="dot" markerWidth="6" markerHeight="6" refX="3" refY="3"><circle cx="3" cy="3" r="2" fill="#333" /></marker>
                        <marker id="arrow-end" markerWidth="6" markerHeight="6" refX="6" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6" fill="#333" /></marker>
                    </defs>
                    <path d="${pathOuter}" fill="${state.polish.waiHu ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <path d="${pathRight}" fill="${state.polish.rightSide ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <path d="${pathFace}" fill="${state.polish.face ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left_back.x}" y2="${p_out_left_back.y}" stroke="black" stroke-width="1" stroke-dasharray="4,4" opacity="0.4" />
                    ${marksSVG}
                    <g font-family="Arial" font-size="24" fill="#333" text-anchor="middle">
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left.x}" y2="${top_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_right.x}" y1="${p_out_right.y}" x2="${p_out_right.x}" y2="${top_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left.x}" y1="${top_chord_y}" x2="${p_out_right.x}" y2="${top_chord_y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <text x="${(p_out_left.x + p_out_right.x)/2}" y="${top_chord_y - 10}" font-size="28">${C_out.toFixed(0)}</text>
                        
                        <path d="M ${p_arc_start.x} ${p_arc_start.y} A ${dim_arc_r} ${dim_arc_r} 0 0 1 ${p_arc_end.x} ${p_arc_end.y}" fill="none" stroke="#333" stroke-width="1" />
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_arc_start.x}" y2="${p_arc_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_right.x}" y1="${p_out_right.y}" x2="${p_arc_end.x}" y2="${p_arc_end.y}" stroke="#666" stroke-width="0.5" />
                        <text x="${p_text_arc.x}" y="${p_text_arc.y - 5}" font-size="28">⌒ ${L_out.toFixed(0)}</text>
                        
                        <path d="M ${p_arc_in_start.x} ${p_arc_in_start.y} A ${dim_arc_in_r} ${dim_arc_in_r} 0 0 1 ${p_arc_in_end.x} ${p_arc_in_end.y}" fill="none" stroke="#333" stroke-width="1" />
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_arc_in_start.x}" y2="${p_arc_in_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_right.x}" y1="${p_in_right.y}" x2="${p_arc_in_end.x}" y2="${p_arc_in_end.y}" stroke="#666" stroke-width="0.5" />
                        <text x="${p_text_arc_in.x}" y="${p_text_arc_in.y + 30}" font-size="28">⌒ ${L_in.toFixed(0)}</text>
                        
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_in_left.x}" y2="${bottom_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_right.x}" y1="${p_in_right.y}" x2="${p_in_right.x}" y2="${bottom_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_left.x}" y1="${bottom_chord_y}" x2="${p_in_right.x}" y2="${bottom_chord_y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <text x="${(p_in_left.x + p_in_right.x)/2}" y="${bottom_chord_y - 10}" font-size="28">${C_in.toFixed(0)}</text>
                        
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_w_start.x}" y2="${p_w_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_w_end.x}" y2="${p_w_end.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_w_start.x}" y1="${p_w_start.y}" x2="${p_w_end.x}" y2="${p_w_end.y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <g transform="rotate(${w_angle}, ${p_w_text.x}, ${p_w_text.y})">
                            <text x="${p_w_text.x}" y="${p_w_text.y - 5}" text-anchor="middle" font-size="28" paint-order="stroke" stroke="white" stroke-width="6">W=${W.toFixed(0)}</text>
                        </g>

                        ${dim_r_out}
                        ${dim_r_in}
                        
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left.x - 30}" y2="${p_out_left.y - 15}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left_back.x}" y1="${p_out_left_back.y}" x2="${p_out_left_back.x - 30}" y2="${p_out_left_back.y - 15}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left.x - 25}" y1="${p_out_left.y - 12.5}" x2="${p_out_left_back.x - 25}" y2="${p_out_left_back.y - 12.5}" stroke="#333" stroke-width="1" />
                        <text x="${p_out_left_back.x - 35}" y="${p_out_left_back.y - 10}" text-anchor="end" alignment-baseline="middle" font-size="24">${T}T</text>

                        ${archHeightSVG}
                        ${totalHeightSVG}
                        ${sideVertHeightSVG}
                    </g>
                </svg>
            `;
            document.getElementById('svgContainer').innerHTML = svg;
        }

        calculate();
    </script>
</body>
</html>
