<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>扇形板计算器 - 智能工程版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
        .polish-btn {
            background-color: white;
            color: #374151;
            border: 1px solid #e5e7eb;
        }
        .polish-btn.active {
            background-color: #374151;
            color: white;
            border-color: #374151;
            font-weight: 600;
        }
        .polish-btn:not(.active):hover {
            background-color: #f9fafb;
        }
        .input-wrapper { position: relative; }
    </style>
</head>
<!-- 修改1：items-start 改为 items-stretch，使左右高度拉伸对齐 -->
<body class="bg-gray-50 text-slate-800 min-h-screen flex flex-col lg:flex-row justify-center items-stretch gap-4 p-6">

    <!-- 左侧控制面板 -->
    <div class="w-full lg:w-80 flex-shrink-0 bg-white p-5 rounded-xl shadow-sm border border-gray-200 flex flex-col">
        <div class="flex items-center justify-between mb-4 border-b pb-3">
            <h1 class="font-bold text-lg text-gray-800">扇形板计算器</h1>
            <button onclick="resetParams()" class="text-xs text-blue-600 flex items-center gap-1 hover:bg-blue-50 px-2 py-1 rounded transition-colors">
                <i data-lucide="rotate-ccw" width="12"></i> 重置
            </button>
        </div>

        <div class="space-y-5 flex-1">
            <!-- 几何参数 -->
            <div>
                <div class="flex justify-between items-end mb-2">
                    <label class="text-xs font-bold text-gray-400 uppercase">任意填入参数即可计算</label>
                </div>
                
                <div class="grid grid-cols-2 gap-3">
                    <div class="input-wrapper">
                        <input type="number" id="radiusOut" value="2000" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外半径 (R外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="radiusIn" value="1200" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内半径 (R内)</span>
                    </div>
                    
                    <!-- 宽度输入 -->
                    <div class="input-wrapper">
                        <input type="number" id="widthVal" placeholder="自动计算" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">宽度 (W)</span>
                    </div>

                    <div class="input-wrapper">
                        <input type="number" id="arcOut" value="1500" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外弧长 (L外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="arcIn" placeholder="自动计算" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内弧长 (L内)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="chordOut" placeholder="自动计算" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">外弦长 (C外)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="chordIn" placeholder="自动计算" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors placeholder-gray-300">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">内弦长 (C内)</span>
                    </div>
                    <div class="input-wrapper">
                        <input type="number" id="thickness" value="30" class="geom-input w-full h-12 px-3 pt-6 pb-1 text-sm font-medium border border-gray-300 rounded outline-none focus:ring-2 focus:ring-gray-200 transition-colors">
                        <span class="absolute left-3 top-1.5 text-[10px] font-bold text-gray-400 pointer-events-none uppercase tracking-wider">厚度 (T)</span>
                    </div>
                </div>
                <div id="statusMsg" class="mt-2 text-xs flex items-start gap-1 text-gray-500 font-medium"></div>
            </div>

            <!-- 磨光面标记 -->
            <div class="pt-2 border-t">
                <label class="text-xs font-bold text-gray-400 uppercase mb-3 block">磨光面标记</label>
                <div class="grid grid-cols-3 gap-2">
                    <button class="polish-btn active flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('face', this)">正面</button>
                    <button class="polish-btn flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('waiHu', this)">外弧面</button>
                    <button class="polish-btn flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('neiHu', this)">内弧面</button>
                    <button class="polish-btn flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('leftSide', this)">左侧面</button>
                    <button class="polish-btn flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('rightSide', this)">右侧面</button>
                    <button class="polish-btn flex items-center justify-center p-2 rounded text-xs transition-all" onclick="togglePolish('back', this)">背面</button>
                </div>
            </div>

            <!-- 计算结果 -->
            <div id="resultBox" class="hidden mt-4 bg-gray-50 rounded-lg p-3 border border-gray-200 text-xs">
                <h3 class="font-bold text-gray-700 mb-2">参数详情 (已计算)</h3>
                <div class="flex flex-col space-y-1" id="resultContent"></div>
            </div>
        </div>
    </div>

    <!-- 右侧预览面板 -->
    <!-- 修改2：移除固定高度 h-[600px]，改为 min-h-[600px]，配合父容器 stretch 实现对齐 -->
    <div class="flex-1 bg-white rounded-xl shadow-sm border border-gray-200 p-4 flex flex-col min-h-[600px] max-w-5xl relative">
        <div class="flex justify-between items-center mb-2 border-b pb-2 z-10 bg-white">
            <h2 class="font-bold text-gray-700 flex items-center gap-2">
                预览图 <span class="text-xs font-normal text-white bg-gray-400 px-2 py-0.5 rounded-full">自动适应</span>
            </h2>
            <button id="downloadBtn" onclick="downloadImage()" disabled class="text-xs bg-gray-800 text-white flex items-center gap-1 px-3 py-1.5 rounded hover:bg-gray-900 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors">
                <i data-lucide="download" width="14"></i> 下载图纸
            </button>
        </div>
        <div id="svgContainer" class="flex-1 w-full h-full flex items-center justify-start overflow-hidden bg-white"></div>
    </div>

    <script>
        lucide.createIcons();

        const state = {
            polish: {
                face: true,
                back: false, 
                waiHu: false,
                neiHu: false,
                leftSide: false,
                rightSide: false
            },
            data: null
        };

        document.querySelectorAll('.geom-input').forEach(input => {
            input.addEventListener('input', calculate);
        });

        function togglePolish(key, btn) {
            state.polish[key] = !state.polish[key];
            if (state.polish[key]) btn.classList.add('active');
            else btn.classList.remove('active');
            draw();
        }

        function resetParams() {
            document.getElementById('radiusOut').value = '2000';
            document.getElementById('radiusIn').value = '1200';
            document.getElementById('widthVal').value = '';
            document.getElementById('arcOut').value = '1500';
            document.getElementById('arcIn').value = '';
            document.getElementById('chordOut').value = '';
            document.getElementById('chordIn').value = '';
            document.getElementById('thickness').value = '30';
            calculate();
        }

        function calculate() {
            const getVal = (id) => {
                const v = parseFloat(document.getElementById(id).value);
                return isNaN(v) ? null : v;
            };

            let inp = {
                ro: getVal('radiusOut'),
                ri: getVal('radiusIn'),
                w:  getVal('widthVal'),
                lo: getVal('arcOut'),
                li: getVal('arcIn'),
                co: getVal('chordOut'),
                ci: getVal('chordIn'),
                t:  getVal('thickness')
            };

            const statusEl = document.getElementById('statusMsg');
            const resultBox = document.getElementById('resultBox');
            const downloadBtn = document.getElementById('downloadBtn');

            if (!inp.t) {
                showError("请输入板厚度");
                return;
            }

            if (inp.ro && inp.ri && !inp.w) inp.w = inp.ro - inp.ri;
            if (inp.ro && inp.w && !inp.ri) inp.ri = inp.ro - inp.w;
            if (inp.ri && inp.w && !inp.ro) inp.ro = inp.ri + inp.w;

            let theta = null;

            if (!theta && inp.lo && inp.ro) theta = inp.lo / inp.ro;
            if (!theta && inp.li && inp.ri) theta = inp.li / inp.ri;

            if (!theta && inp.co && inp.ro) {
                if (inp.co <= 2 * inp.ro) theta = 2 * Math.asin(inp.co / (2 * inp.ro));
            }
            if (!theta && inp.ci && inp.ri) {
                if (inp.ci <= 2 * inp.ri) theta = 2 * Math.asin(inp.ci / (2 * inp.ri));
            }

            if (!theta && inp.lo && inp.li && inp.w) {
                 theta = (inp.lo - inp.li) / inp.w;
            }

            if (theta && theta > 0) {
                if (!inp.ro) {
                    if (inp.lo) inp.ro = inp.lo / theta;
                    else if (inp.co) inp.ro = inp.co / (2 * Math.sin(theta/2));
                }
                if (!inp.ri) {
                    if (inp.li) inp.ri = inp.li / theta;
                    else if (inp.ci) inp.ri = inp.ci / (2 * Math.sin(theta/2));
                }
            }

            if (!inp.w && inp.ro && inp.ri) inp.w = inp.ro - inp.ri;
            if (inp.w && !inp.ri && inp.ro) inp.ri = inp.ro - inp.w;

            let error = null;
            let ro = inp.ro;
            let ri = inp.ri;

            if (!theta) {
                if ((ro || ri) && !inp.lo && !inp.li && !inp.co && !inp.ci) error = "请输入任意 [弧长] 或 [弦长] 确定角度";
                else if (inp.lo && inp.li && !inp.w && !ro && !ri) error = "请输入 [宽度] 或 [半径] 以计算";
                else error = "参数不足，无法构建图形";
            } else {
                if (!ro && !ri) error = "无法确定半径";
                else if (ro && ri && ro <= ri) error = "外半径必须大于内半径";
                else if (theta > Math.PI * 2) error = "角度过大 (>360°)";
            }

            if (!error) {
                const res = {
                    ro: ro, ri: ri,
                    lo: theta * ro, li: theta * ri,
                    co: 2 * ro * Math.sin(theta/2), ci: 2 * ri * Math.sin(theta/2),
                    w: ro - ri, angle: theta * 180 / Math.PI, t: inp.t
                };
                state.data = { valid: true, theta: theta, ...res };

                statusEl.innerHTML = `<i data-lucide="check-circle-2" width="12"></i> 生成成功`;
                statusEl.className = "mt-2 text-xs flex items-center gap-1 text-green-600 font-medium";
                resultBox.classList.remove('hidden');
                
                const fmt = (n) => n.toFixed(1);
                // 修改3：去掉了 text-blue-600，改为 text-gray-800，统一显示为深色
                const isAuto = (val, id) => document.getElementById(id).value == '' ? 'font-mono font-bold text-gray-800' : 'font-mono text-gray-700';
                
                document.getElementById('resultContent').innerHTML = `
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">侧边宽(W)</span> <span class="${isAuto(res.w, 'widthVal')}">${fmt(res.w)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">圆心角</span> <span class="font-mono text-black">${fmt(res.angle)}°</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">内弧长</span> <span class="${isAuto(res.li, 'arcIn')}">${fmt(res.li)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">外弦长</span> <span class="${isAuto(res.co, 'chordOut')}">${fmt(res.co)}</span></div>
                    <div class="flex justify-between border-b border-gray-100 pb-1"><span class="text-gray-400">内弦长</span> <span class="${isAuto(res.ci, 'chordIn')}">${fmt(res.ci)}</span></div>
                    <div class="flex justify-between"><span class="text-gray-400">外弧长</span> <span class="${isAuto(res.lo, 'arcOut')}">${fmt(res.lo)}</span></div>
                `;
                downloadBtn.disabled = false;
                lucide.createIcons();
                draw();
            } else {
                showError(error || "请输入参数");
            }
        }

        function showError(msg) {
            state.data = { valid: false };
            const statusEl = document.getElementById('statusMsg');
            statusEl.innerHTML = `<i data-lucide="alert-circle" width="12"></i> ${msg}`;
            statusEl.className = "mt-2 text-xs flex items-center gap-1 text-amber-600 font-medium";
            document.getElementById('resultBox').classList.add('hidden');
            document.getElementById('downloadBtn').disabled = true;
            document.getElementById('svgContainer').innerHTML = `
                <div class="text-center text-gray-300">
                    <i data-lucide="box" class="mx-auto mb-2 w-12 h-12 opacity-20"></i>
                    <p>${msg}</p>
                </div>
            `;
            lucide.createIcons();
        }

        function draw() {
            if (!state.data || !state.data.valid) return;
            const { theta, ro: R_out, ri: R_in, t: T, lo: L_out, li: L_in, co: C_out, ci: C_in, w: W } = state.data;

            const polarToCartesian = (r, angle) => ({
                x: r * Math.sin(angle),
                y: -r * Math.cos(angle)
            });

            const startAngle = -theta / 2;
            const endAngle = theta / 2;

            const p_out_left = polarToCartesian(R_out, startAngle);
            const p_out_right = polarToCartesian(R_out, endAngle);
            const p_in_left = polarToCartesian(R_in, startAngle);
            const p_in_right = polarToCartesian(R_in, endAngle);

            const depthAngle = 45 * Math.PI / 180;
            const depthLen = T * 0.8; 
            const dx = depthLen * Math.sin(depthAngle);
            const dy = -depthLen * Math.cos(depthAngle);
            const project = (p) => ({ x: p.x + dx, y: p.y + dy });

            const p_out_left_back = project(p_out_left);
            const p_out_right_back = project(p_out_right);
            const p_in_right_back = project(p_in_right);
            const p_in_left_back = project(p_in_left);

            const pathFace = `M ${p_out_left.x} ${p_out_left.y} A ${R_out} ${R_out} 0 0 1 ${p_out_right.x} ${p_out_right.y} L ${p_in_right.x} ${p_in_right.y} A ${R_in} ${R_in} 0 0 0 ${p_in_left.x} ${p_in_left.y} Z`;
            const pathOuter = `M ${p_out_left.x} ${p_out_left.y} L ${p_out_left_back.x} ${p_out_left_back.y} A ${R_out} ${R_out} 0 0 1 ${p_out_right_back.x} ${p_out_right_back.y} L ${p_out_right.x} ${p_out_right.y} A ${R_out} ${R_out} 0 0 0 ${p_out_left.x} ${p_out_left.y} Z`;
            const pathRight = `M ${p_out_right.x} ${p_out_right.y} L ${p_out_right_back.x} ${p_out_right_back.y} L ${p_in_right_back.x} ${p_in_right_back.y} L ${p_in_right.x} ${p_in_right.y} Z`;

            const colorWhite = "#ffffff";
            const colorPolish = "#e5e7eb"; 
            
            const top_apex_y = -R_out;
            const top_chord_y = top_apex_y - 40;
            
            const dim_arc_r = R_out + 120;
            const p_arc_start = polarToCartesian(dim_arc_r, startAngle);
            const p_arc_end = polarToCartesian(dim_arc_r, endAngle);
            const p_text_arc = polarToCartesian(dim_arc_r + 5, 0); 

            const dim_arc_in_r = R_in - 50;
            const p_arc_in_start = polarToCartesian(dim_arc_in_r, startAngle);
            const p_arc_in_end = polarToCartesian(dim_arc_in_r, endAngle);
            const p_text_arc_in = polarToCartesian(dim_arc_in_r - 10, 0);

            const bottom_chord_y = Math.max(p_in_left.y, p_in_right.y) + 140;
            
            const left_dx = p_out_left.x - p_in_left.x;
            const left_dy = p_out_left.y - p_in_left.y;
            const len = Math.sqrt(left_dx*left_dx + left_dy*left_dy);
            const nx = left_dy / len; 
            const ny = -left_dx / len;
            const offset_w = 120; 
            const p_w_start = { x: p_out_left.x + nx * offset_w, y: p_out_left.y + ny * offset_w };
            const p_w_end = { x: p_in_left.x + nx * offset_w, y: p_in_left.y + ny * offset_w };
            const p_w_text = { x: (p_w_start.x + p_w_end.x)/2, y: (p_w_start.y + p_w_end.y)/2 };
            const w_angle = Math.atan2(p_w_end.y - p_w_start.y, p_w_end.x - p_w_start.x) * 180 / Math.PI;
            const p_thick_end = p_out_left_back;

            const markSize = 16;
            const markPath = `M ${-markSize/2} ${-markSize} L ${markSize/2} ${-markSize} L 0 0 Z`;
            let marksSVG = '';

            if (state.polish.face) {
                const r_mid = (R_out + R_in) / 2;
                const p_mid = polarToCartesian(r_mid, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mid.x}, ${p_mid.y})" />`;
            }
            if (state.polish.waiHu) {
                const p_top = polarToCartesian(R_out + 6, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_top.x}, ${p_top.y})" />`;
            }
            if (state.polish.back) {
                const angle_back = 3 * Math.PI / 180;
                // 修改4：背面标记向外移动 2px (R_out + 4)
                const p_base = polarToCartesian(R_out + 4, angle_back);
                const p_back = { x: p_base.x + dx, y: p_base.y + dy }; 
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_back.x}, ${p_back.y}) rotate(30)" />`;
            }
            if (state.polish.neiHu) {
                const p_bot = polarToCartesian(R_in - 6, 0);
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_bot.x}, ${p_bot.y}) rotate(180)" />`;
            }
            if (state.polish.leftSide) {
                const r_mid = (R_out + R_in) / 2;
                const p_edge = polarToCartesian(r_mid, startAngle);
                const ang_out = startAngle - Math.PI/2;
                const p_mark = { x: p_edge.x + 1 * Math.sin(ang_out), y: p_edge.y - 1 * Math.cos(ang_out) };
                const rot = (startAngle * 180 / Math.PI) - 90;
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mark.x}, ${p_mark.y}) rotate(${rot})" />`;
            }
            if (state.polish.rightSide) {
                const r_mid = (R_out + R_in) / 2;
                const p_edge = polarToCartesian(r_mid, endAngle);
                const ang_out = endAngle + Math.PI/2;
                const p_mark = { x: p_edge.x + 1 * Math.sin(ang_out), y: p_edge.y - 1 * Math.cos(ang_out) };
                const rot = (endAngle * 180 / Math.PI) + 90;
                marksSVG += `<path d="${markPath}" fill="black" transform="translate(${p_mark.x}, ${p_mark.y}) rotate(${rot})" />`;
            }

            const createRadialDim = (r, angle, text) => {
                const p_start = polarToCartesian(r, angle);
                const p_end = polarToCartesian(r - 150, angle);
                const p_text = polarToCartesian(r - 75, angle);
                const rot = (angle * 180 / Math.PI) + 90;
                
                return `
                    <circle cx="${p_start.x}" cy="${p_start.y}" r="3" fill="#333" />
                    <line x1="${p_start.x}" y1="${p_start.y}" x2="${p_end.x}" y2="${p_end.y}" stroke="#333" stroke-width="1" />
                    <g transform="translate(${p_text.x}, ${p_text.y}) rotate(${rot})">
                        <text x="0" y="0" text-anchor="middle" dy="-5" font-size="24" fill="#333">${text}</text>
                    </g>
                `;
            };

            const dim_r_out = createRadialDim(R_out, startAngle + theta * 0.15, `R${R_out.toFixed(0)}`);
            const dim_r_in = createRadialDim(R_in, endAngle - theta * 0.15, `R${R_in.toFixed(0)}`);

            const pointsX = [p_out_left.x, p_out_right.x, p_out_right.x + 80, p_w_start.x - 60, p_thick_end.x - 50];
            const pointsY = [polarToCartesian(dim_arc_r + 40, 0).y, bottom_chord_y + 50, p_out_right.y];
            const minX = Math.min(...pointsX);
            const maxX = Math.max(...pointsX);
            const minY = Math.min(...pointsY);
            const maxY = Math.max(...pointsY);
            const w_box = maxX - minX;
            const h_box = maxY - minY;
            const padding = 20;
            const viewBox = `${minX - padding} ${minY - padding} ${w_box + 2*padding} ${h_box + 2*padding}`;

            const svg = `
                <svg id="mainSvg" width="100%" height="100%" viewBox="${viewBox}" preserveAspectRatio="xMinYMid meet" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <marker id="dot" markerWidth="6" markerHeight="6" refX="3" refY="3"><circle cx="3" cy="3" r="2" fill="#333" /></marker>
                        <marker id="arrow-end" markerWidth="6" markerHeight="6" refX="6" refY="3" orient="auto"><path d="M0,0 L6,3 L0,6" fill="#333" /></marker>
                    </defs>
                    <path d="${pathOuter}" fill="${state.polish.waiHu ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <path d="${pathRight}" fill="${state.polish.rightSide ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <path d="${pathFace}" fill="${state.polish.face ? colorPolish : colorWhite}" stroke="black" stroke-width="1.5" stroke-linejoin="round" />
                    <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left_back.x}" y2="${p_out_left_back.y}" stroke="black" stroke-width="1" stroke-dasharray="4,4" opacity="0.4" />
                    ${marksSVG}
                    <g font-family="Arial" font-size="24" fill="#333" text-anchor="middle">
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left.x}" y2="${top_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_right.x}" y1="${p_out_right.y}" x2="${p_out_right.x}" y2="${top_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left.x}" y1="${top_chord_y}" x2="${p_out_right.x}" y2="${top_chord_y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <text x="${(p_out_left.x + p_out_right.x)/2}" y="${top_chord_y - 10}" font-size="28">${C_out.toFixed(0)}</text>
                        
                        <path d="M ${p_arc_start.x} ${p_arc_start.y} A ${dim_arc_r} ${dim_arc_r} 0 0 1 ${p_arc_end.x} ${p_arc_end.y}" fill="none" stroke="#333" stroke-width="1" />
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_arc_start.x}" y2="${p_arc_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_right.x}" y1="${p_out_right.y}" x2="${p_arc_end.x}" y2="${p_arc_end.y}" stroke="#666" stroke-width="0.5" />
                        <text x="${p_text_arc.x}" y="${p_text_arc.y - 5}" font-size="28">⌒ ${L_out.toFixed(0)}</text>
                        
                        <path d="M ${p_arc_in_start.x} ${p_arc_in_start.y} A ${dim_arc_in_r} ${dim_arc_in_r} 0 0 1 ${p_arc_in_end.x} ${p_arc_in_end.y}" fill="none" stroke="#333" stroke-width="1" />
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_arc_in_start.x}" y2="${p_arc_in_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_right.x}" y1="${p_in_right.y}" x2="${p_arc_in_end.x}" y2="${p_arc_in_end.y}" stroke="#666" stroke-width="0.5" />
                        <text x="${p_text_arc_in.x}" y="${p_text_arc_in.y + 30}" font-size="28">⌒ ${L_in.toFixed(0)}</text>
                        
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_in_left.x}" y2="${bottom_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_right.x}" y1="${p_in_right.y}" x2="${p_in_right.x}" y2="${bottom_chord_y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_left.x}" y1="${bottom_chord_y}" x2="${p_in_right.x}" y2="${bottom_chord_y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <text x="${(p_in_left.x + p_in_right.x)/2}" y="${bottom_chord_y - 10}" font-size="28">${C_in.toFixed(0)}</text>
                        
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_w_start.x}" y2="${p_w_start.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_in_left.x}" y1="${p_in_left.y}" x2="${p_w_end.x}" y2="${p_w_end.y}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_w_start.x}" y1="${p_w_start.y}" x2="${p_w_end.x}" y2="${p_w_end.y}" stroke="#333" stroke-width="1" marker-start="url(#dot)" marker-end="url(#dot)" />
                        <g transform="rotate(${w_angle}, ${p_w_text.x}, ${p_w_text.y})">
                            <text x="${p_w_text.x}" y="${p_w_text.y - 5}" text-anchor="middle" font-size="28" paint-order="stroke" stroke="white" stroke-width="6">W=${W.toFixed(0)}</text>
                        </g>

                        ${dim_r_out}
                        ${dim_r_in}
                        
                        <line x1="${p_out_left.x}" y1="${p_out_left.y}" x2="${p_out_left.x - 30}" y2="${p_out_left.y - 15}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left_back.x}" y1="${p_out_left_back.y}" x2="${p_out_left_back.x - 30}" y2="${p_out_left_back.y - 15}" stroke="#666" stroke-width="0.5" />
                        <line x1="${p_out_left.x - 25}" y1="${p_out_left.y - 12.5}" x2="${p_out_left_back.x - 25}" y2="${p_out_left_back.y - 12.5}" stroke="#333" stroke-width="1" />
                        <text x="${p_out_left_back.x - 35}" y="${p_out_left_back.y - 10}" text-anchor="end" alignment-baseline="middle" font-size="24">${T}T</text>
                    </g>
                </svg>
            `;
            document.getElementById('svgContainer').innerHTML = svg;
        }

        calculate();
    </script>
</body>
</html>
