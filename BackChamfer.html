<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>背倒+倒角</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0; padding: 0; 
            width: 100%;
            background-color: #f0f2f5;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            overflow-y: auto; 
        }

        .container {
            display: flex;
            flex-direction: column;
            max-width: 800px;
            margin: 0 auto;
            background: white;
            min-height: 100vh;
            box-shadow: 0 0 20px rgba(0,0,0,0.05);
        }

        /* --- 绘图区域 --- */
        .drawing-area {
            width: 100%;
            height: 320px; 
            background-color: #fff;
            position: relative;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* --- 底部操作区域 --- */
        .controls-area {
            padding: 15px;
            background-color: #fff;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding-bottom: 40px;
        }

        /* 网格布局 */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px;
        }
        
        .control-grid-4 {
            display: grid;
            grid-template-columns: repeat(4, 1fr); 
            gap: 10px;
        }
        
        /* 按钮网格：3列 */
        .toggle-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); 
            gap: 10px;
        }

        .form-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .form-item label {
            font-size: 12px;
            color: #666;
            font-weight: 500;
            text-align: center;
            white-space: nowrap;
        }

        .form-control {
            height: 40px;
            border: 1px solid #d9d9d9;
            border-radius: 6px;
            padding: 0 4px;
            font-size: 16px;
            background: #fff;
            width: 100%;
            text-align: center;
            -webkit-appearance: none; 
            color: #333;
        }

        .form-control[readonly] {
            background-color: #f5f5f5;
            color: #888;
            border-color: #e8e8e8;
        }
        
        select.form-control {
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23007CB2%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right .5em top 50%;
            background-size: .65em auto;
            padding-right: 1.2em;
        }

        .form-control:focus {
            border-color: #40a9ff;
            outline: none;
            box-shadow: 0 0 0 2px rgba(24, 144, 255, 0.2);
        }

        /* 开关按钮通用样式 */
        .toggle-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 40px;
            background: #f5f5f5;
            border-radius: 6px;
            border: 1px solid #d9d9d9;
            cursor: pointer;
            user-select: none;
            font-size: 14px;
            color: #666;
            transition: all 0.2s;
        }
        
        /* 激活状态样式 */
        .toggle-btn.active {
            background: #e6f7ff;
            border-color: #1890ff;
            color: #1890ff;
            font-weight: bold;
        }
        
        .toggle-btn.active-red {
            background: #fff1f0;
            border-color: #ff4d4f;
            color: #ff4d4f;
            font-weight: bold;
        }

        .toggle-btn.active-green {
            background: #f6ffed;
            border-color: #52c41a;
            color: #52c41a;
            font-weight: bold;
        }

        /* 结果展示区 */
        .result-section {
            background: #f7f9fc;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .result-text {
            font-family: "Times New Roman", serif;
            font-size: 16px; 
            font-weight: bold;
            color: #333;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .btn {
            height: 44px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .btn:active { opacity: 0.8; }
        .btn-success { background-color: #52c41a; color: white; }
        
        .btn-copy {
            background-color: white;
            border: 1px solid #1890ff;
            color: #1890ff;
            font-size: 13px;
            height: 32px;
            padding: 0 12px;
            border-radius: 4px;
            white-space: nowrap;
        }

    </style>
</head>
<body>

<div class="container">
    <div class="drawing-area">
        <svg id="drawingSvg" viewBox="0 0 800 500" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <pattern id="mixedHatch" patternUnits="userSpaceOnUse" width="30" height="30" patternTransform="rotate(-45)">
                    <line x1="0" y1="0" x2="30" y2="0" stroke="#000" stroke-width="1" />
                    <line x1="0" y1="15" x2="30" y2="15" stroke="#000" stroke-width="1" stroke-dasharray="8,6" />
                </pattern>
                <marker id="dot" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto">
                    <circle cx="4" cy="4" r="3" fill="red" />
                </marker>
                <!-- 箭头marker (保留定义但此处不使用) -->
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                    <path d="M0,0 L0,6 L9,3 z" fill="red" />
                </marker>
            </defs>
            <g id="svgContent"></g>
        </svg>
    </div>
    
    <div class="controls-area">
        <!-- 第一行 -->
        <div class="control-grid">
            <div class="form-item">
                <label style="color:#1890ff; font-weight:bold;">板厚 (mm)</label>
                <input type="number" id="thicknessInput" class="form-control" value="30" oninput="onThicknessChange()">
            </div>
            <div class="form-item">
                <label>位置</label>
                <select id="idxInput" class="form-control" onchange="updateAll()">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="左">左</option>
                    <option value="右">右</option>
                </select>
            </div>
            <div class="form-item">
                <label>类型</label>
                <select id="typeInput" class="form-control" onchange="updateAll()">
                    <option value="W">W</option>
                    <option value="L">L</option>
                </select>
            </div>
        </div>

        <!-- 第二行 -->
        <div class="control-grid-4">
            <div class="form-item">
                <label>切宽</label>
                <input type="number" id="widthInput" class="form-control" value="20" oninput="onWidthChange()">
            </div>
            <div class="form-item">
                <label>切深</label>
                <input type="number" id="heightInput" class="form-control" value="20" oninput="onHeightChange()">
            </div>
            <div class="form-item">
                <label>上倒角</label>
                <input type="number" id="chamferInput" class="form-control" value="0" placeholder="0" oninput="updateAll()">
            </div>
            <div class="form-item">
                <label>余 (自动)</label>
                <input type="number" id="remainInput" class="form-control" value="10" readonly>
            </div>
        </div>

        <!-- 第三行：开关按钮组 (3列布局) -->
        <div class="toggle-grid">
             <div id="polishBtn" class="toggle-btn" onclick="togglePolish()">无光</div>
             <div id="accurateBtn" class="toggle-btn" onclick="toggleAccurate()">准确</div>
             <div id="topDimBtn" class="toggle-btn active-green" onclick="toggleTopDim()">顶标 (开)</div>
             <div id="unitBtn" class="toggle-btn" onclick="toggleUnit()">倒角单位 (关)</div>
             <!-- 新增倒角光按钮 -->
             <div id="chamferPolishBtn" class="toggle-btn" onclick="toggleChamferPolish()">倒角光 (关)</div>
        </div>

        <!-- 结果文字展示与复制 -->
        <div class="result-section">
            <div class="result-text" id="resultDisplay">1W背倒20*20余10</div>
            <button class="btn btn-copy" onclick="copyText()">复制</button>
        </div>
        
        <!-- 底部大按钮 -->
        <button class="btn btn-success" onclick="downloadJPG()">下载高清 JPG 图片</button>
    </div>
</div>

<script>
    const svg = document.getElementById('drawingSvg');
    const svgContent = document.getElementById('svgContent');
    
    // Inputs
    const idxInput = document.getElementById('idxInput');
    const typeInput = document.getElementById('typeInput');
    const thicknessInput = document.getElementById('thicknessInput');
    const widthInput = document.getElementById('widthInput');
    const heightInput = document.getElementById('heightInput');
    const remainInput = document.getElementById('remainInput');
    const chamferInput = document.getElementById('chamferInput');
    
    const polishBtn = document.getElementById('polishBtn');
    const accurateBtn = document.getElementById('accurateBtn');
    const topDimBtn = document.getElementById('topDimBtn');
    const unitBtn = document.getElementById('unitBtn');
    const chamferPolishBtn = document.getElementById('chamferPolishBtn');
    
    const resultDisplay = document.getElementById('resultDisplay');

    let isPolished = false;
    let isAccurate = false;
    let showTopDim = true;
    let showChamferUnit = false; 
    let isChamferPolished = false; // 倒角光状态

    window.onload = function() {
        updateAll();
    };
    setTimeout(updateAll, 100);

    // --- 联动逻辑 ---

    function onThicknessChange() {
        calculateRemain();
        updateAll();
    }

    function onWidthChange() {
        const w = parseInt(widthInput.value) || 0;
        heightInput.value = w; 
        calculateRemain();
        updateAll();
    }

    function onHeightChange() {
        calculateRemain();
        updateAll();
    }

    function calculateRemain() {
        const t = parseInt(thicknessInput.value) || 0;
        const h = parseInt(heightInput.value) || 0;
        const r = t - h;
        remainInput.value = r >= 0 ? r : 0; 
    }

    function togglePolish() {
        isPolished = !isPolished;
        if (isPolished) {
            polishBtn.classList.add('active');
            polishBtn.textContent = "有光";
        } else {
            polishBtn.classList.remove('active');
            polishBtn.textContent = "无光";
        }
        updateAll();
    }

    function toggleAccurate() {
        isAccurate = !isAccurate;
        if (isAccurate) {
            accurateBtn.classList.add('active-red');
            accurateBtn.textContent = "准确 (开)";
        } else {
            accurateBtn.classList.remove('active-red');
            accurateBtn.textContent = "准确 (关)";
        }
        updateAll();
    }

    function toggleTopDim() {
        showTopDim = !showTopDim;
        if (showTopDim) {
            topDimBtn.classList.add('active-green');
            topDimBtn.textContent = "顶标 (开)";
        } else {
            topDimBtn.classList.remove('active-green');
            topDimBtn.textContent = "顶标 (关)";
        }
        updateAll();
    }
    
    function toggleUnit() {
        showChamferUnit = !showChamferUnit;
        if (showChamferUnit) {
            unitBtn.classList.add('active');
            unitBtn.textContent = "倒角单位 (开)";
        } else {
            unitBtn.classList.remove('active');
            unitBtn.textContent = "倒角单位 (关)";
        }
        updateAll();
    }

    function toggleChamferPolish() {
        isChamferPolished = !isChamferPolished;
        if (isChamferPolished) {
            chamferPolishBtn.classList.add('active');
            chamferPolishBtn.textContent = "倒角光 (开)";
        } else {
            chamferPolishBtn.classList.remove('active');
            chamferPolishBtn.textContent = "倒角光 (关)";
        }
        updateAll();
    }

    function updateAll() {
        const idx = idxInput.value;
        const type = typeInput.value;
        const w = parseInt(widthInput.value) || 0;
        const h = parseInt(heightInput.value) || 0;
        const r = parseInt(remainInput.value) || 0;
        const t = parseInt(thicknessInput.value) || 0; 
        const c = parseFloat(chamferInput.value) || 0;

        // 生成文字
        // 格式调整：1W倒角3mm，背倒20*20余10
        let text = `${idx}${type}`;
        
        if (c > 0) {
            text += `倒角${c}mm，`;
        }
        
        text += `背倒${w}*${h}余${r}`;
        
        if (isPolished) text += "光";
        if (isChamferPolished && c > 0) text += "(倒角光)"; 
        
        // 准确逻辑
        if (isAccurate) {
            text += `,余${r}准确`;
        }

        resultDisplay.textContent = text;

        // 绘图数据
        const data = {
            index: idx,
            dimType: type,
            cutWidth: w,
            cutHeight: h,
            remaining: r,
            isPolished: isPolished,
            totalThickness: t,
            showTopDim: showTopDim,
            chamfer: c,
            showUnit: showChamferUnit,
            isChamferPolished: isChamferPolished
        };

        drawSVG(data);
    }

    function copyText() {
        const text = resultDisplay.textContent;
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text).then(showCopySuccess).catch(() => fallbackCopy(text));
        } else {
            fallbackCopy(text);
        }
    }

    function fallbackCopy(text) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        try {
            document.execCommand('copy');
            showCopySuccess();
        } catch (err) {
            alert('复制失败');
        }
        document.body.removeChild(textArea);
    }

    function showCopySuccess() {
        const btn = document.querySelector('.btn-copy');
        const originalText = btn.textContent;
        btn.textContent = "OK!";
        btn.style.borderColor = "#52c41a";
        btn.style.color = "#52c41a";
        setTimeout(() => {
            btn.textContent = originalText;
            btn.style.borderColor = "#1890ff";
            btn.style.color = "#1890ff";
        }, 1500);
    }

    // --- 绘图逻辑 ---
    const LOGICAL_WIDTH = 800;
    const LOGICAL_HEIGHT = 500;

    function drawSVG(data) {
        while (svgContent.firstChild) {
            svgContent.removeChild(svgContent.firstChild);
        }

        const width = LOGICAL_WIDTH;
        const height = LOGICAL_HEIGHT;
        
        const sidePadding = 50;
        const topPadding = 60;
        const bottomAreaHeight = 50; 
        
        const availableW = width - sidePadding * 2;
        const availableH = height - topPadding - bottomAreaHeight; 

        const logicalH = data.totalThickness;
        if (logicalH <= 0) return;

        const logicalW = logicalH * 4.5; 
        
        const scale = Math.min(availableW / logicalW, availableH / logicalH) * 0.85;

        const offsetX = sidePadding + (availableW - logicalW * scale) / 2;
        const offsetY = topPadding + (availableH - logicalH * scale) / 2;

        const toX = (val) => offsetX + val * scale;
        const toY = (val) => offsetY + val * scale;

        // 基础点计算
        const pTopLeft = { x: toX(0), y: toY(0) };
        const pChamferStart = { x: toX(0), y: toY(data.remaining) };
        const pChamferEnd = { x: toX(data.cutWidth), y: toY(data.totalThickness) };
        const pBottomRight = { x: toX(logicalW), y: toY(data.totalThickness) };
        const pTopRight = { x: toX(logicalW), y: toY(0) };

        // 倒角逻辑
        let points = "";
        let chamferP1 = null;
        let chamferP2 = null;

        if (data.chamfer > 0) {
            // 左上角倒角：从(c,0)到(0,c)
            // 限制倒角大小不超过余量和宽度
            const c = Math.min(data.chamfer, data.remaining - 0.5, logicalW/2); 
            
            chamferP1 = { x: toX(c), y: toY(0) }; // 顶边点
            chamferP2 = { x: toX(0), y: toY(c) }; // 左边点

            points = `
                ${chamferP1.x},${chamferP1.y} 
                ${chamferP2.x},${chamferP2.y} 
                ${pChamferStart.x},${pChamferStart.y} 
                ${pChamferEnd.x},${pChamferEnd.y} 
                ${pBottomRight.x},${pBottomRight.y} 
                ${pTopRight.x},${pTopRight.y}
            `;
        } else {
            points = `
                ${pTopLeft.x},${pTopLeft.y} 
                ${pChamferStart.x},${pChamferStart.y} 
                ${pChamferEnd.x},${pChamferEnd.y} 
                ${pBottomRight.x},${pBottomRight.y} 
                ${pTopRight.x},${pTopRight.y}
            `;
        }
        
        // 1. 填充
        createSvgElement('polygon', {
            points: points,
            fill: 'url(#mixedHatch)',
            stroke: 'none'
        });
        
        // 2. 轮廓
        createSvgElement('polygon', {
            points: points,
            fill: 'none',
            stroke: 'black',
            'stroke-width': 3
        });

        // 3. 标注
        
        // --- 顶部标注 (可开关) ---
        if (data.showTopDim) {
            const topY = pTopLeft.y - 30;
            drawDimLine(pTopLeft.x, topY, pTopRight.x, topY, data.dimType, false, -25, 36);
            
            // 辅助线
            const guideY = topY - 5;
            
            if (data.chamfer > 0 && chamferP1) {
                 // 虚拟角点延长线
                 createSvgElement('line', {
                     x1: chamferP1.x, y1: chamferP1.y, x2: pTopLeft.x, y2: pTopLeft.y,
                     stroke: 'black', 'stroke-width': 1
                 });
                 createSvgElement('line', {
                     x1: chamferP2.x, y1: chamferP2.y, x2: pTopLeft.x, y2: pTopLeft.y,
                     stroke: 'black', 'stroke-width': 1
                 });
                 
                 createLine(pTopLeft.x, pTopLeft.y, pTopLeft.x, guideY);
            } else {
                 createLine(pTopLeft.x, pTopLeft.y, pTopLeft.x, guideY);
            }
            createLine(pTopRight.x, pTopRight.y, pTopRight.x, guideY);
        }

        // 右侧板厚
        const rightX = pTopRight.x + 45;
        drawDimLine(rightX, pTopRight.y, rightX, pBottomRight.y, data.totalThickness + "T", true, 20);
        createLine(pTopRight.x, pTopRight.y, rightX + 5, pTopRight.y);
        createLine(pBottomRight.x, pBottomRight.y, rightX + 5, pBottomRight.y);

        // 左侧余量
        const leftLabelX = pTopLeft.x - 45;
        if (data.remaining > 0) {
            let topRefY = pTopLeft.y;
            if (data.chamfer > 0 && chamferP2) {
                drawDimLine(leftLabelX, topRefY, leftLabelX, pChamferStart.y, data.remaining, true, -20);
                createLine(pTopLeft.x, pTopLeft.y, leftLabelX - 5, pTopLeft.y);
            } else {
                drawDimLine(leftLabelX, topRefY, leftLabelX, pChamferStart.y, data.remaining, true, -20);
                createLine(pTopLeft.x, pTopLeft.y, leftLabelX - 5, pTopLeft.y);
            }
            createLine(pChamferStart.x, pChamferStart.y, leftLabelX - 5, pChamferStart.y);
        }

        // 切深
        drawDimLine(leftLabelX, pChamferStart.y, leftLabelX, pChamferEnd.y, data.cutHeight, true, -20);
        createLine(pChamferEnd.x, pChamferEnd.y, leftLabelX - 5, pChamferEnd.y);
        if (data.remaining <= 0) {
             createLine(pTopLeft.x, pTopLeft.y, leftLabelX - 5, pTopLeft.y);
        }

        // 底部切宽
        const bottomLabelY = pBottomRight.y + 40;
        const cutX = pChamferEnd.x;
        const zeroX = pTopLeft.x;
        
        drawDimLine(zeroX, bottomLabelY, cutX, bottomLabelY, data.cutWidth, false, -10);
        createLine(zeroX, pBottomRight.y, zeroX, bottomLabelY + 5);
        createLine(cutX, pBottomRight.y, cutX, bottomLabelY + 5);

        // 倒角标注
        if (data.chamfer > 0 && chamferP1 && chamferP2) {
            const offsetDist = 25; 
            const angle45 = Math.PI / 4;
            const offX = -offsetDist * Math.cos(angle45);
            const offY = -offsetDist * Math.sin(angle45);
            
            const dimP1 = { x: chamferP1.x + offX, y: chamferP1.y + offY };
            const dimP2 = { x: chamferP2.x + offX, y: chamferP2.y + offY };
            
            createLine(chamferP1.x, chamferP1.y, dimP1.x, dimP1.y);
            createLine(chamferP2.x, chamferP2.y, dimP2.x, dimP2.y);
            
            createSvgElement('line', {
                x1: dimP1.x, y1: dimP1.y, x2: dimP2.x, y2: dimP2.y,
                stroke: 'red', 'stroke-width': 1,
                'marker-start': 'url(#dot)',
                'marker-end': 'url(#dot)'
            });
            
            const chamferText = data.chamfer + (data.showUnit ? "mm" : "");
            const midX = (dimP1.x + dimP2.x) / 2;
            const midY = (dimP1.y + dimP2.y) / 2;
            
            createSvgElement('text', {
                x: midX, y: midY,
                'font-family': 'Times New Roman',
                'font-size': '24px',
                fill: 'red',
                'text-anchor': 'middle',
                'dominant-baseline': 'alphabetic', 
                transform: `rotate(-45, ${midX}, ${midY}) translate(0, -5)`
            }, chamferText);
        }

        // 三角指示符 (Top & Side)
        const triHalfW = 6;
        const triLen = 12;
        const triGap = 8;

        const topTriX = (pTopLeft.x + pTopRight.x) / 2;
        const topTriY = pTopLeft.y - triGap; 
        createSvgElement('polygon', {
            points: `${topTriX - triHalfW},${topTriY - triLen} ${topTriX + triHalfW},${topTriY - triLen} ${topTriX},${topTriY}`,
            fill: 'black'
        });

        if (data.isPolished) {
            const sideTriX = pTopLeft.x - triGap;
            const sideTriY = (pTopLeft.y + pChamferStart.y) / 2;
            createSvgElement('polygon', {
                points: `${sideTriX - triLen},${sideTriY - triHalfW} ${sideTriX},${sideTriY} ${sideTriX - triLen},${sideTriY + triHalfW}`,
                fill: 'black'
            });
        }
        
        // 倒角磨光三角指示符 (New)
        if (data.isChamferPolished && data.chamfer > 0 && chamferP1 && chamferP2) {
            const midX = (chamferP1.x + chamferP2.x) / 2;
            const midY = (chamferP1.y + chamferP2.y) / 2;
            
            const normalX = -1; 
            const normalY = -1;
            const len = Math.sqrt(2);
            const uX = normalX / len;
            const uY = normalY / len;
            
            // 修改：尖端距离倒角面3px
            const gap = 3;
            const tipX = midX + uX * gap;
            const tipY = midY + uY * gap;
            
            // 底边中心
            const baseCX = tipX + uX * triLen;
            const baseCY = tipY + uY * triLen;
            
            // 底边两点 (垂直于法线)
            const pX = 1 / len;
            const pY = -1 / len;
            
            const b1x = baseCX + pX * triHalfW;
            const b1y = baseCY + pY * triHalfW;
            const b2x = baseCX - pX * triHalfW;
            const b2y = baseCY - pY * triHalfW;
            
            createSvgElement('polygon', {
                points: `${tipX},${tipY} ${b1x},${b1y} ${b2x},${b2y}`,
                fill: 'black'
            });
        }
    }

    function createSvgElement(type, attrs, textContent) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", type);
        for (const [key, value] of Object.entries(attrs)) {
            el.setAttribute(key, value);
        }
        if (textContent) {
            el.textContent = textContent;
        }
        svgContent.appendChild(el);
        return el;
    }

    function createLine(x1, y1, x2, y2) {
        createSvgElement('line', {
            x1: x1, y1: y1, x2: x2, y2: y2,
            stroke: 'red', 'stroke-width': 1
        });
    }

    function drawDimLine(x1, y1, x2, y2, text, isVertical, textOffset = 0, fontSize = 24) {
        createSvgElement('line', {
            x1: x1, y1: y1, x2: x2, y2: y2,
            stroke: 'red', 'stroke-width': 1,
            'marker-start': 'url(#dot)',
            'marker-end': 'url(#dot)'
        });

        const midX = (x1 + x2) / 2;
        const midY = (y1 + y2) / 2;
        
        const textAttrs = {
            'font-family': 'Times New Roman',
            'font-size': fontSize + 'px',
            fill: 'red',
            'text-anchor': 'middle',
            'dominant-baseline': 'middle'
        };

        if (isVertical) {
            textAttrs.transform = `rotate(-90, ${midX}, ${midY})`;
            textAttrs.y = midY + textOffset; 
            textAttrs.x = midX;
        } else {
            textAttrs.x = midX;
            textAttrs.y = midY + textOffset; 
        }
        
        createSvgElement('text', textAttrs, text);
    }

    function downloadJPG() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        // 高清倍率
        const scaleFactor = 4;
        const w = LOGICAL_WIDTH;
        const h = LOGICAL_HEIGHT;
        
        canvas.width = w * scaleFactor;
        canvas.height = h * scaleFactor;
        
        const serializer = new XMLSerializer();
        let source = serializer.serializeToString(svg);
        
        if (!source.includes('width=')) {
             source = source.replace('<svg', `<svg width="${w}" height="${h}"`);
        }
        if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
            source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
        }

        const img = new Image();
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(source);
        
        img.onload = function() {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            const a = document.createElement('a');
            a.download = resultDisplay.textContent + '.jpg';
            a.href = canvas.toDataURL('image/jpeg', 0.9);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };
    }
</script>

</body>
</html>
