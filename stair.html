import React, { useState, useRef, useEffect } from 'react';
import { Image as ImageIcon, Settings2, Triangle, ArrowRightFromLine, ArrowDownFromLine } from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Button } from "@/components/ui/button";
import { Switch } from "@/components/ui/switch";

const TreadGenerator = () => {
  const [params, setParams] = useState({
    totalWidth: 130,
    thickness: 30,
    leftMargin: 20,
    grooveCount: 3,
    grooveDepth: 5,
    chamferTop: 3,
    chamferBottom: 2,
  });

  // 独立管理槽宽数组和间距数组
  const [grooveWidths, setGrooveWidths] = useState([10, 10, 10]);
  const [gaps, setGaps] = useState([5, 5]);
  
  // 两个独立的基准开关
  const [showTopDatum, setShowTopDatum] = useState(true);
  const [showSideDatum, setShowSideDatum] = useState(true);

  const svgRef = useRef(null);

  // 当槽数量变化时，同步更新槽宽数组和间距数组
  useEffect(() => {
    const count = Math.max(1, params.grooveCount);
    const gapCount = Math.max(0, count - 1);

    setGrooveWidths(prev => {
      if (prev.length === count) return prev;
      if (prev.length < count) {
        const newWidths = [...prev];
        while (newWidths.length < count) {
          // 新增的槽宽默认取前一个的值，或者默认10
          newWidths.push(newWidths.length > 0 ? newWidths[newWidths.length - 1] : 10);
        }
        return newWidths;
      } else {
        return prev.slice(0, count);
      }
    });

    setGaps(prev => {
      if (prev.length === gapCount) return prev;
      if (prev.length < gapCount) {
        const newGaps = [...prev];
        while (newGaps.length < gapCount) {
          newGaps.push(newGaps.length > 0 ? newGaps[newGaps.length - 1] : 5);
        }
        return newGaps;
      } else {
        return prev.slice(0, gapCount);
      }
    });
  }, [params.grooveCount]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setParams(prev => ({
      ...prev,
      [name]: Number(value)
    }));
  };

  const handleGrooveWidthChange = (index, value) => {
    const newWidths = [...grooveWidths];
    newWidths[index] = Number(value);
    setGrooveWidths(newWidths);
  };

  const handleGapChange = (index, value) => {
    const newGaps = [...gaps];
    newGaps[index] = Number(value);
    setGaps(newGaps);
  };

  const generatePath = () => {
    const { 
      totalWidth: W, thickness: H, leftMargin: L1, 
      grooveCount, grooveDepth: Gd, 
      chamferTop: C1, chamferBottom: C2 
    } = params;

    let d = `M 0 ${C1}`; 
    d += ` L ${C1} 0`;   
    d += ` L ${L1} 0`;   

    let currentX = L1;

    for (let i = 0; i < grooveCount; i++) {
      const gw = grooveWidths[i] || 10;
      d += ` L ${currentX} ${Gd}`;
      d += ` L ${currentX + gw} ${Gd}`;
      d += ` L ${currentX + gw} 0`;
      
      currentX += gw;

      if (i < grooveCount - 1) {
        const currentGap = gaps[i] || 5;
        d += ` L ${currentX + currentGap} 0`;
        currentX += currentGap;
      }
    }

    d += ` L ${W} 0`; 
    d += ` L ${W} ${H}`; 
    d += ` L ${C2} ${H}`; 
    d += ` L 0 ${H - C2}`; 
    d += ` Z`;
    return d;
  };

  const downloadJpg = () => {
    const svgElement = svgRef.current;
    if (!svgElement) return;

    const serializer = new XMLSerializer();
    let source = serializer.serializeToString(svgElement);

    if(!source.match(/^<svg[^>]+xmlns="http\:\/\/www\.w3\.org\/2000\/svg"/)){
        source = source.replace(/^<svg/, '<svg xmlns="http://www.w3.org/2000/svg"');
    }

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();

    const viewBoxAttr = svgElement.getAttribute('viewBox').split(' ').map(Number);
    const [vbX, vbY, vbW, vbH] = viewBoxAttr;

    const scale = 3; 
    canvas.width = vbW * scale;
    canvas.height = vbH * scale;

    const svgBlob = new Blob([source], {type: "image/svg+xml;charset=utf-8"});
    const url = URL.createObjectURL(svgBlob);

    img.onload = () => {
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      
      const jpgUrl = canvas.toDataURL('image/jpeg', 1.0);
      const link = document.createElement("a");
      link.href = jpgUrl;
      link.download = `tread_section_${params.grooveCount}grooves.jpg`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    };
    img.src = url;
  };

  const Defs = () => (
    <defs>
      <marker id="dot-red" markerWidth="8" markerHeight="8" refX="4" refY="4" orient="auto" markerUnits="strokeWidth">
        <circle cx="4" cy="4" r="2.5" fill="red" />
      </marker>
      <pattern id="hatch" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
        <line x1="0" y1="0" x2="0" y2="8" stroke="#000" strokeWidth="1" />
      </pattern>
    </defs>
  );

  const Dimension = ({ x1, y1, x2, y2, text, offset = 20, vertical = false, color = "red" }) => {
    let lx1, ly1, lx2, ly2;
    let bx1_s, by1_s, bx1_e, by1_e;
    let bx2_s, by2_s, bx2_e, by2_e;
    let tx, ty;
    const ext = 3; const gap = 1; 

    if (vertical) {
      lx1 = x1 - offset; ly1 = y1;
      lx2 = x2 - offset; ly2 = y2;
      bx1_s = x1 - gap; by1_s = y1; bx1_e = lx1 - ext; by1_e = y1;
      bx2_s = x2 - gap; by2_s = y2; bx2_e = lx2 - ext; by2_e = y2;
      tx = lx1 - 4; ty = (y1 + y2) / 2;
    } else {
      lx1 = x1; ly1 = y1 - offset;
      lx2 = x2; ly2 = y2 - offset;
      bx1_s = x1; by1_s = y1 - gap; bx1_e = x1; by1_e = ly1 - ext;
      bx2_s = x2; by2_s = y2 - gap; bx2_e = x2; by2_e = ly2 - ext;
      tx = (x1 + x2) / 2; ty = ly1 - 4;
    }

    return (
      <g>
        <line x1={bx1_s} y1={by1_s} x2={bx1_e} y2={by1_e} stroke={color} strokeWidth="0.5" />
        <line x1={bx2_s} y1={by2_s} x2={bx2_e} y2={by2_e} stroke={color} strokeWidth="0.5" />
        <line x1={lx1} y1={ly1} x2={lx2} y2={ly2} stroke={color} strokeWidth="0.5" markerStart="url(#dot-red)" markerEnd="url(#dot-red)" />
        <text x={tx} y={ty} fill={color} fontSize="10" textAnchor={vertical ? "end" : "middle"} alignmentBaseline={vertical ? "middle" : "baseline"}>{text}</text>
      </g>
    );
  };

  const ChamferLabel = ({ size, x, y, position }) => {
    if (!size || size <= 0) return null;
    const isTop = position === 'top-left';
    const startX = size / 2;
    const startY = isTop ? size / 2 : y - size / 2;
    const endX = -25; 
    const endY = isTop ? -15 : y + 15;
    
    return (
      <g>
        <line x1={startX} y1={startY} x2={endX} y2={endY} stroke="red" strokeWidth="0.5" />
        <line x1={endX} y1={endY} x2={endX - 10} y2={endY} stroke="red" strokeWidth="0.5" />
        <text x={endX - 12} y={endY} fill="red" fontSize="10" textAnchor="end" alignmentBaseline="middle">
          倒角{size}mm
        </text>
      </g>
    );
  };

  const DatumTriangle = ({ x, y, direction }) => {
    const size = 8;
    const offset = 8; 
    let points = "";
    
    if (direction === 'down') {
      const tipY = y - offset;
      points = `${x},${tipY} ${x-size/2},${tipY-size} ${x+size/2},${tipY-size}`;
    } else {
      const tipX = x - offset;
      points = `${tipX},${y} ${tipX-size},${y-size/2} ${tipX-size},${y+size/2}`;
    }
    
    return <polygon points={points} fill="black" />;
  };

  const paddingLeft = 80; 
  const paddingRight = 40; 
  const paddingTop = 80;   
  const paddingBottom = 60; 
  
  const viewBoxX = -paddingLeft;
  const viewBoxY = -paddingTop;
  const viewBoxW = params.totalWidth + paddingLeft + paddingRight;
  const viewBoxH = params.thickness + paddingTop + paddingBottom;

  return (
    <div className="flex flex-col lg:flex-row gap-4 p-2 w-full max-w-6xl mx-auto">
      <Card className="w-full lg:w-1/3 h-fit">
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <Settings2 className="w-5 h-5" />
            参数设置
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          
          {/* 基准开关区域 */}
          <div className="bg-slate-50 p-3 rounded-md border space-y-2">
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium flex items-center gap-2">
                <ArrowDownFromLine className="w-3 h-3" />
                顶部三角
              </Label>
              <Switch checked={showTopDatum} onCheckedChange={setShowTopDatum} />
            </div>
            <div className="flex items-center justify-between">
              <Label className="text-sm font-medium flex items-center gap-2">
                <ArrowRightFromLine className="w-3 h-3" />
                侧面三角
              </Label>
              <Switch checked={showSideDatum} onCheckedChange={setShowSideDatum} />
            </div>
          </div>

          <div className="grid grid-cols-2 gap-3">
            <div><Label>总宽度 (W)</Label><Input type="number" name="totalWidth" value={params.totalWidth} onChange={handleChange} /></div>
            <div><Label>厚度 (T)</Label><Input type="number" name="thickness" value={params.thickness} onChange={handleChange} /></div>
          </div>

          <div className="grid grid-cols-2 gap-3 pt-2 border-t">
             <div><Label className="text-xs text-gray-500">上倒角</Label><Input type="number" name="chamferTop" value={params.chamferTop} onChange={handleChange} /></div>
             <div><Label className="text-xs text-gray-500">下倒角</Label><Input type="number" name="chamferBottom" value={params.chamferBottom} onChange={handleChange} /></div>
          </div>

          <div className="space-y-2 pt-2 border-t">
            <Label className="text-blue-600 font-bold">开槽配置</Label>
            <div className="grid grid-cols-2 gap-3">
              <div className="col-span-2">
                <Label className="text-blue-800">凹槽数量</Label>
                <Input type="number" name="grooveCount" value={params.grooveCount} onChange={handleChange} />
              </div>
              <div><Label className="text-xs text-gray-500">左边距</Label><Input type="number" name="leftMargin" value={params.leftMargin} onChange={handleChange} /></div>
              <div><Label className="text-xs text-gray-500">槽深</Label><Input type="number" name="grooveDepth" value={params.grooveDepth} onChange={handleChange} /></div>
            </div>
            
            {/* 独立槽宽设置 */}
            <div className="mt-2 bg-blue-50 p-2 rounded border border-blue-100">
              <Label className="text-xs font-bold text-blue-800 mb-2 block">各槽宽度设置 (从左到右)</Label>
              <div className="grid grid-cols-3 gap-2">
                {grooveWidths.map((width, index) => (
                  <div key={index}>
                    <Label className="text-[10px] text-gray-500">槽 {index + 1}</Label>
                    <Input 
                      type="number" 
                      value={width} 
                      onChange={(e) => handleGrooveWidthChange(index, e.target.value)} 
                      className="h-8 text-sm"
                    />
                  </div>
                ))}
              </div>
            </div>

            {/* 独立间距设置 */}
            {gaps.length > 0 && (
              <div className="mt-2 bg-gray-50 p-2 rounded border">
                <Label className="text-xs font-bold text-gray-700 mb-2 block">各槽间距设置 (从左到右)</Label>
                <div className="grid grid-cols-3 gap-2">
                  {gaps.map((gap, index) => (
                    <div key={index}>
                      <Label className="text-[10px] text-gray-500">间距 {index + 1}</Label>
                      <Input 
                        type="number" 
                        value={gap} 
                        onChange={(e) => handleGapChange(index, e.target.value)} 
                        className="h-8 text-sm"
                      />
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

          <Button className="w-full mt-4 bg-green-600 hover:bg-green-700" onClick={downloadJpg}>
            <ImageIcon className="w-4 h-4 mr-2" />
            下载 JPG 图片
          </Button>
        </CardContent>
      </Card>

      <Card className="w-full lg:w-2/3 bg-white">
        <CardHeader className="pb-2">
          <CardTitle>预览</CardTitle>
        </CardHeader>
        <CardContent className="flex justify-center items-center p-2">
          <div className="border rounded-md bg-white w-full overflow-hidden">
            <svg 
              ref={svgRef}
              width="100%" 
              viewBox={`${viewBoxX} ${viewBoxY} ${viewBoxW} ${viewBoxH}`}
              style={{ fontFamily: 'Arial, sans-serif' }}
            >
              <Defs />
              <path d={generatePath()} fill="url(#hatch)" stroke="black" strokeWidth="1.2" />

              {/* 基准三角 */}
              {showTopDatum && <DatumTriangle x={params.totalWidth/2} y={0} direction="down" />}
              {showSideDatum && <DatumTriangle x={0} y={params.thickness/2} direction="right" />}

              <Dimension x1={0} y1={0} x2={params.leftMargin} y2={0} offset={15} text={params.leftMargin} />

              {Array.from({ length: params.grooveCount }).map((_, i) => {
                // 计算当前槽的起始X坐标
                let startX = params.leftMargin;
                for(let j=0; j<i; j++) {
                  startX += (grooveWidths[j] || 10);
                  startX += (gaps[j] || 5);
                }
                
                const currentGw = grooveWidths[i] || 10;
                const currentGap = gaps[i] || 5;

                return (
                  <React.Fragment key={i}>
                    <Dimension x1={startX} y1={0} x2={startX + currentGw} y2={0} offset={35} text={currentGw} />
                    {i < params.grooveCount - 1 && (
                      <Dimension x1={startX + currentGw} y1={0} x2={startX + currentGw + currentGap} y2={0} offset={15} text={currentGap} />
                    )}
                  </React.Fragment>
                );
              })}

              <Dimension x1={0} y1={0} x2={params.totalWidth} y2={0} offset={60} text="W" />
              <Dimension x1={0} y1={0} x2={0} y2={params.thickness} offset={30} vertical={true} text={`${params.thickness}T`} />

              <ChamferLabel size={params.chamferTop} x={0} y={0} position="top-left" />
              <ChamferLabel size={params.chamferBottom} x={0} y={params.thickness} position="bottom-left" />

              {(() => {
                 // 计算最后一个槽的结束位置，用于标注槽深
                 let lastGrooveX = params.leftMargin;
                 for(let j=0; j<params.grooveCount; j++) {
                   lastGrooveX += (grooveWidths[j] || 10);
                   if (j < params.grooveCount - 1) {
                     lastGrooveX += (gaps[j] || 5);
                   }
                 }
                 
                 const markX = lastGrooveX;
                 return (
                   <g>
                      <line x1={markX} y1={params.grooveDepth} x2={markX + 12} y2={params.grooveDepth} stroke="red" strokeWidth="0.5" />
                      <line x1={markX} y1={0} x2={markX + 12} y2={0} stroke="red" strokeWidth="0.5" />
                      <line x1={markX + 8} y1={0} x2={markX + 8} y2={params.grooveDepth} stroke="red" strokeWidth="0.5" markerStart="url(#dot-red)" markerEnd="url(#dot-red)"/>
                      <text x={markX + 15} y={params.grooveDepth/2 + 2} fill="red" fontSize="10">{params.grooveDepth}</text>
                   </g>
                 )
              })()}

              <text x={params.totalWidth / 2} y={params.thickness + 40} textAnchor="middle" fontSize="24" fill="black" style={{fontWeight: 'bold', letterSpacing: '4px'}}>踏板截面图</text>
            </svg>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default TreadGenerator;
